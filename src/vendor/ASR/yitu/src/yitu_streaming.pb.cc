// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yitu_streaming.proto

#include "yitu_streaming.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR AudioConfig::AudioConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.aue_)*/0
  , /*decltype(_impl_.samplerate_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioConfigDefaultTypeInternal() {}
  union {
    AudioConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
PROTOBUF_CONSTEXPR SpeechConfig::SpeechConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.customword_)*/{}
  , /*decltype(_impl_.usecustomwordsid_)*/{}
  , /*decltype(_impl_._usecustomwordsid_cached_byte_size_)*/{0}
  , /*decltype(_impl_.keywords_)*/{}
  , /*decltype(_impl_.wordsreplace_)*/nullptr
  , /*decltype(_impl_.lang_)*/0
  , /*decltype(_impl_.scene_)*/0
  , /*decltype(_impl_.recognizetype_)*/0
  , /*decltype(_impl_.disableconvertnumber_)*/false
  , /*decltype(_impl_.disablepunctuation_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpeechConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpeechConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpeechConfigDefaultTypeInternal() {}
  union {
    SpeechConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpeechConfigDefaultTypeInternal _SpeechConfig_default_instance_;
PROTOBUF_CONSTEXPR WordsReplace::WordsReplace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keywords_)*/{}
  , /*decltype(_impl_.replace_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WordsReplaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WordsReplaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WordsReplaceDefaultTypeInternal() {}
  union {
    WordsReplace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WordsReplaceDefaultTypeInternal _WordsReplace_default_instance_;
PROTOBUF_CONSTEXPR StreamingSpeechConfig::StreamingSpeechConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.audioconfig_)*/nullptr
  , /*decltype(_impl_.speechconfig_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingSpeechConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingSpeechConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingSpeechConfigDefaultTypeInternal() {}
  union {
    StreamingSpeechConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingSpeechConfigDefaultTypeInternal _StreamingSpeechConfig_default_instance_;
PROTOBUF_CONSTEXPR StreamingSpeechRequest::StreamingSpeechRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requestPayload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StreamingSpeechRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingSpeechRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingSpeechRequestDefaultTypeInternal() {}
  union {
    StreamingSpeechRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingSpeechRequestDefaultTypeInternal _StreamingSpeechRequest_default_instance_;
PROTOBUF_CONSTEXPR StreamingSpeechResponse::StreamingSpeechResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.globalstreamid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingSpeechResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingSpeechResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingSpeechResponseDefaultTypeInternal() {}
  union {
    StreamingSpeechResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingSpeechResponseDefaultTypeInternal _StreamingSpeechResponse_default_instance_;
PROTOBUF_CONSTEXPR StreamingSpeechResult::StreamingSpeechResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.besttranscription_)*/nullptr
  , /*decltype(_impl_.isfinal_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingSpeechResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingSpeechResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingSpeechResultDefaultTypeInternal() {}
  union {
    StreamingSpeechResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingSpeechResultDefaultTypeInternal _StreamingSpeechResult_default_instance_;
PROTOBUF_CONSTEXPR StreamingSpeechStatus::StreamingSpeechStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.processedtimestamp_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingSpeechStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingSpeechStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingSpeechStatusDefaultTypeInternal() {}
  union {
    StreamingSpeechStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingSpeechStatusDefaultTypeInternal _StreamingSpeechStatus_default_instance_;
PROTOBUF_CONSTEXPR StreamingTranscription::StreamingTranscription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keywordstype_)*/{}
  , /*decltype(_impl_.piece_)*/{}
  , /*decltype(_impl_.transcribedtext_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingTranscriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingTranscriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingTranscriptionDefaultTypeInternal() {}
  union {
    StreamingTranscription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingTranscriptionDefaultTypeInternal _StreamingTranscription_default_instance_;
PROTOBUF_CONSTEXPR KeyWordsType::KeyWordsType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keywords_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.keywordsscore_)*/0
  , /*decltype(_impl_.starttimestamp_)*/0
  , /*decltype(_impl_.endtimestamp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyWordsTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyWordsTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyWordsTypeDefaultTypeInternal() {}
  union {
    KeyWordsType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyWordsTypeDefaultTypeInternal _KeyWordsType_default_instance_;
PROTOBUF_CONSTEXPR StreamingTranscriptionPiece::StreamingTranscriptionPiece(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transcribedtext_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.begintimestamp_)*/int64_t{0}
  , /*decltype(_impl_.endtimestamp_)*/int64_t{0}
  , /*decltype(_impl_.transcribedtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamingTranscriptionPieceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamingTranscriptionPieceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamingTranscriptionPieceDefaultTypeInternal() {}
  union {
    StreamingTranscriptionPiece _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamingTranscriptionPieceDefaultTypeInternal _StreamingTranscriptionPiece_default_instance_;
static ::_pb::Metadata file_level_metadata_yitu_5fstreaming_2eproto[11];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_yitu_5fstreaming_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_yitu_5fstreaming_2eproto = nullptr;

const uint32_t TableStruct_yitu_5fstreaming_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AudioConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AudioConfig, _impl_.aue_),
  PROTOBUF_FIELD_OFFSET(::AudioConfig, _impl_.samplerate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.lang_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.scene_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.customword_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.usecustomwordsid_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.recognizetype_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.disableconvertnumber_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.disablepunctuation_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.wordsreplace_),
  PROTOBUF_FIELD_OFFSET(::SpeechConfig, _impl_.keywords_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::WordsReplace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::WordsReplace, _impl_.keywords_),
  PROTOBUF_FIELD_OFFSET(::WordsReplace, _impl_.replace_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechConfig, _impl_.audioconfig_),
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechConfig, _impl_.speechconfig_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechRequest, _impl_.requestPayload_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResponse, _impl_.globalstreamid_),
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResponse, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResult, _impl_.isfinal_),
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechResult, _impl_.besttranscription_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingSpeechStatus, _impl_.processedtimestamp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingTranscription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingTranscription, _impl_.transcribedtext_),
  PROTOBUF_FIELD_OFFSET(::StreamingTranscription, _impl_.keywordstype_),
  PROTOBUF_FIELD_OFFSET(::StreamingTranscription, _impl_.piece_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::KeyWordsType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::KeyWordsType, _impl_.keywords_),
  PROTOBUF_FIELD_OFFSET(::KeyWordsType, _impl_.keywordsscore_),
  PROTOBUF_FIELD_OFFSET(::KeyWordsType, _impl_.starttimestamp_),
  PROTOBUF_FIELD_OFFSET(::KeyWordsType, _impl_.endtimestamp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamingTranscriptionPiece, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamingTranscriptionPiece, _impl_.transcribedtext_),
  PROTOBUF_FIELD_OFFSET(::StreamingTranscriptionPiece, _impl_.begintimestamp_),
  PROTOBUF_FIELD_OFFSET(::StreamingTranscriptionPiece, _impl_.endtimestamp_),
  PROTOBUF_FIELD_OFFSET(::StreamingTranscriptionPiece, _impl_.transcribedtype_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::AudioConfig)},
  { 8, -1, -1, sizeof(::SpeechConfig)},
  { 23, -1, -1, sizeof(::WordsReplace)},
  { 31, -1, -1, sizeof(::StreamingSpeechConfig)},
  { 39, -1, -1, sizeof(::StreamingSpeechRequest)},
  { 48, -1, -1, sizeof(::StreamingSpeechResponse)},
  { 57, -1, -1, sizeof(::StreamingSpeechResult)},
  { 65, -1, -1, sizeof(::StreamingSpeechStatus)},
  { 72, -1, -1, sizeof(::StreamingTranscription)},
  { 81, -1, -1, sizeof(::KeyWordsType)},
  { 91, -1, -1, sizeof(::StreamingTranscriptionPiece)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_AudioConfig_default_instance_._instance,
  &::_SpeechConfig_default_instance_._instance,
  &::_WordsReplace_default_instance_._instance,
  &::_StreamingSpeechConfig_default_instance_._instance,
  &::_StreamingSpeechRequest_default_instance_._instance,
  &::_StreamingSpeechResponse_default_instance_._instance,
  &::_StreamingSpeechResult_default_instance_._instance,
  &::_StreamingSpeechStatus_default_instance_._instance,
  &::_StreamingTranscription_default_instance_._instance,
  &::_KeyWordsType_default_instance_._instance,
  &::_StreamingTranscriptionPiece_default_instance_._instance,
};

const char descriptor_table_protodef_yitu_5fstreaming_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024yitu_streaming.proto\"\211\001\n\013AudioConfig\022\'"
  "\n\003aue\030\001 \001(\0162\032.AudioConfig.AudioEncoding\022"
  "\022\n\nsampleRate\030\002 \001(\005\"=\n\rAudioEncoding\022\017\n\013"
  "UNSPECIFIED\020\000\022\007\n\003PCM\020\001\022\007\n\003AAC\020\002\022\t\n\005MPEG2"
  "\020\003\"\266\003\n\014SpeechConfig\022$\n\004lang\030\001 \001(\0162\026.Spee"
  "chConfig.Language\022\"\n\005scene\030\002 \001(\0162\023.Speec"
  "hConfig.Scene\022\022\n\ncustomWord\030\003 \003(\t\022\030\n\020use"
  "CustomWordsId\030\004 \003(\005\0222\n\rrecognizeType\030\005 \001"
  "(\0162\033.SpeechConfig.RecognizeType\022\034\n\024disab"
  "leConvertNumber\030\006 \001(\010\022\032\n\022disablePunctuat"
  "ion\030\007 \001(\010\022#\n\014wordsReplace\030\010 \001(\0132\r.WordsR"
  "eplace\022\020\n\010keyWords\030\t \003(\t\"6\n\010Language\022\017\n\013"
  "UNSPECIFIED\020\000\022\014\n\010MANDARIN\020\001\022\013\n\007ENGLISH\020\002"
  "\"\031\n\005Scene\022\020\n\014GENERALSCENE\020\000\"6\n\rRecognize"
  "Type\022\007\n\003ALL\020\000\022\r\n\tUTTERANCE\020\001\022\r\n\tSTREAMIN"
  "G\020\002\"1\n\014WordsReplace\022\020\n\010keywords\030\001 \003(\t\022\017\n"
  "\007replace\030\002 \003(\t\"_\n\025StreamingSpeechConfig\022"
  "!\n\013audioConfig\030\001 \001(\0132\014.AudioConfig\022#\n\014sp"
  "eechConfig\030\002 \001(\0132\r.SpeechConfig\"x\n\026Strea"
  "mingSpeechRequest\0227\n\025streamingSpeechConf"
  "ig\030\001 \001(\0132\026.StreamingSpeechConfigH\000\022\023\n\tau"
  "dioData\030\002 \001(\014H\000B\020\n\016requestPayload\"\201\001\n\027St"
  "reamingSpeechResponse\022\026\n\016globalStreamId\030"
  "\001 \001(\t\022&\n\006result\030\002 \001(\0132\026.StreamingSpeechR"
  "esult\022&\n\006status\030\003 \001(\0132\026.StreamingSpeechS"
  "tatus\"\\\n\025StreamingSpeechResult\022\017\n\007isFina"
  "l\030\001 \001(\010\0222\n\021bestTranscription\030\002 \001(\0132\027.Str"
  "eamingTranscription\"3\n\025StreamingSpeechSt"
  "atus\022\032\n\022processedTimestamp\030\001 \001(\003\"\203\001\n\026Str"
  "eamingTranscription\022\027\n\017transcribedText\030\001"
  " \001(\t\022#\n\014keyWordsType\030\002 \003(\0132\r.KeyWordsTyp"
  "e\022+\n\005piece\030\003 \003(\0132\034.StreamingTranscriptio"
  "nPiece\"e\n\014KeyWordsType\022\020\n\010keyWords\030\001 \001(\t"
  "\022\025\n\rkeyWordsScore\030\002 \001(\002\022\026\n\016startTimestam"
  "p\030\003 \001(\005\022\024\n\014endTimestamp\030\004 \001(\005\"}\n\033Streami"
  "ngTranscriptionPiece\022\027\n\017transcribedText\030"
  "\001 \001(\t\022\026\n\016beginTimestamp\030\002 \001(\003\022\024\n\014endTime"
  "stamp\030\003 \001(\003\022\027\n\017transcribedType\030\004 \001(\0052]\n\021"
  "SpeechRecognition\022H\n\017RecognizeStream\022\027.S"
  "treamingSpeechRequest\032\030.StreamingSpeechR"
  "esponse(\0010\001B(\n\023com.yitutech.speechB\017Stre"
  "amingProtosP\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_yitu_5fstreaming_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_yitu_5fstreaming_2eproto = {
    false, false, 1661, descriptor_table_protodef_yitu_5fstreaming_2eproto,
    "yitu_streaming.proto",
    &descriptor_table_yitu_5fstreaming_2eproto_once, nullptr, 0, 11,
    schemas, file_default_instances, TableStruct_yitu_5fstreaming_2eproto::offsets,
    file_level_metadata_yitu_5fstreaming_2eproto, file_level_enum_descriptors_yitu_5fstreaming_2eproto,
    file_level_service_descriptors_yitu_5fstreaming_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_yitu_5fstreaming_2eproto_getter() {
  return &descriptor_table_yitu_5fstreaming_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_yitu_5fstreaming_2eproto(&descriptor_table_yitu_5fstreaming_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioConfig_AudioEncoding_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_yitu_5fstreaming_2eproto);
  return file_level_enum_descriptors_yitu_5fstreaming_2eproto[0];
}
bool AudioConfig_AudioEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioConfig_AudioEncoding AudioConfig::UNSPECIFIED;
constexpr AudioConfig_AudioEncoding AudioConfig::PCM;
constexpr AudioConfig_AudioEncoding AudioConfig::AAC;
constexpr AudioConfig_AudioEncoding AudioConfig::MPEG2;
constexpr AudioConfig_AudioEncoding AudioConfig::AudioEncoding_MIN;
constexpr AudioConfig_AudioEncoding AudioConfig::AudioEncoding_MAX;
constexpr int AudioConfig::AudioEncoding_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_Language_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_yitu_5fstreaming_2eproto);
  return file_level_enum_descriptors_yitu_5fstreaming_2eproto[1];
}
bool SpeechConfig_Language_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SpeechConfig_Language SpeechConfig::UNSPECIFIED;
constexpr SpeechConfig_Language SpeechConfig::MANDARIN;
constexpr SpeechConfig_Language SpeechConfig::ENGLISH;
constexpr SpeechConfig_Language SpeechConfig::Language_MIN;
constexpr SpeechConfig_Language SpeechConfig::Language_MAX;
constexpr int SpeechConfig::Language_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_Scene_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_yitu_5fstreaming_2eproto);
  return file_level_enum_descriptors_yitu_5fstreaming_2eproto[2];
}
bool SpeechConfig_Scene_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SpeechConfig_Scene SpeechConfig::GENERALSCENE;
constexpr SpeechConfig_Scene SpeechConfig::Scene_MIN;
constexpr SpeechConfig_Scene SpeechConfig::Scene_MAX;
constexpr int SpeechConfig::Scene_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_RecognizeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_yitu_5fstreaming_2eproto);
  return file_level_enum_descriptors_yitu_5fstreaming_2eproto[3];
}
bool SpeechConfig_RecognizeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SpeechConfig_RecognizeType SpeechConfig::ALL;
constexpr SpeechConfig_RecognizeType SpeechConfig::UTTERANCE;
constexpr SpeechConfig_RecognizeType SpeechConfig::STREAMING;
constexpr SpeechConfig_RecognizeType SpeechConfig::RecognizeType_MIN;
constexpr SpeechConfig_RecognizeType SpeechConfig::RecognizeType_MAX;
constexpr int SpeechConfig::RecognizeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class AudioConfig::_Internal {
 public:
};

AudioConfig::AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AudioConfig)
}
AudioConfig::AudioConfig(const AudioConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.aue_){}
    , decltype(_impl_.samplerate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.aue_, &from._impl_.aue_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.samplerate_) -
    reinterpret_cast<char*>(&_impl_.aue_)) + sizeof(_impl_.samplerate_));
  // @@protoc_insertion_point(copy_constructor:AudioConfig)
}

inline void AudioConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.aue_){0}
    , decltype(_impl_.samplerate_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioConfig::~AudioConfig() {
  // @@protoc_insertion_point(destructor:AudioConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:AudioConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.aue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.samplerate_) -
      reinterpret_cast<char*>(&_impl_.aue_)) + sizeof(_impl_.samplerate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .AudioConfig.AudioEncoding aue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aue(static_cast<::AudioConfig_AudioEncoding>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 sampleRate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.samplerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AudioConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .AudioConfig.AudioEncoding aue = 1;
  if (this->_internal_aue() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_aue(), target);
  }

  // int32 sampleRate = 2;
  if (this->_internal_samplerate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_samplerate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AudioConfig)
  return target;
}

size_t AudioConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AudioConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AudioConfig.AudioEncoding aue = 1;
  if (this->_internal_aue() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_aue());
  }

  // int32 sampleRate = 2;
  if (this->_internal_samplerate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_samplerate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioConfig::GetClassData() const { return &_class_data_; }


void AudioConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioConfig*>(&to_msg);
  auto& from = static_cast<const AudioConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AudioConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_aue() != 0) {
    _this->_internal_set_aue(from._internal_aue());
  }
  if (from._internal_samplerate() != 0) {
    _this->_internal_set_samplerate(from._internal_samplerate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioConfig::CopyFrom(const AudioConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AudioConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioConfig::IsInitialized() const {
  return true;
}

void AudioConfig::InternalSwap(AudioConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioConfig, _impl_.samplerate_)
      + sizeof(AudioConfig::_impl_.samplerate_)
      - PROTOBUF_FIELD_OFFSET(AudioConfig, _impl_.aue_)>(
          reinterpret_cast<char*>(&_impl_.aue_),
          reinterpret_cast<char*>(&other->_impl_.aue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[0]);
}

// ===================================================================

class SpeechConfig::_Internal {
 public:
  static const ::WordsReplace& wordsreplace(const SpeechConfig* msg);
};

const ::WordsReplace&
SpeechConfig::_Internal::wordsreplace(const SpeechConfig* msg) {
  return *msg->_impl_.wordsreplace_;
}
SpeechConfig::SpeechConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SpeechConfig)
}
SpeechConfig::SpeechConfig(const SpeechConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpeechConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.customword_){from._impl_.customword_}
    , decltype(_impl_.usecustomwordsid_){from._impl_.usecustomwordsid_}
    , /*decltype(_impl_._usecustomwordsid_cached_byte_size_)*/{0}
    , decltype(_impl_.keywords_){from._impl_.keywords_}
    , decltype(_impl_.wordsreplace_){nullptr}
    , decltype(_impl_.lang_){}
    , decltype(_impl_.scene_){}
    , decltype(_impl_.recognizetype_){}
    , decltype(_impl_.disableconvertnumber_){}
    , decltype(_impl_.disablepunctuation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_wordsreplace()) {
    _this->_impl_.wordsreplace_ = new ::WordsReplace(*from._impl_.wordsreplace_);
  }
  ::memcpy(&_impl_.lang_, &from._impl_.lang_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disablepunctuation_) -
    reinterpret_cast<char*>(&_impl_.lang_)) + sizeof(_impl_.disablepunctuation_));
  // @@protoc_insertion_point(copy_constructor:SpeechConfig)
}

inline void SpeechConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.customword_){arena}
    , decltype(_impl_.usecustomwordsid_){arena}
    , /*decltype(_impl_._usecustomwordsid_cached_byte_size_)*/{0}
    , decltype(_impl_.keywords_){arena}
    , decltype(_impl_.wordsreplace_){nullptr}
    , decltype(_impl_.lang_){0}
    , decltype(_impl_.scene_){0}
    , decltype(_impl_.recognizetype_){0}
    , decltype(_impl_.disableconvertnumber_){false}
    , decltype(_impl_.disablepunctuation_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpeechConfig::~SpeechConfig() {
  // @@protoc_insertion_point(destructor:SpeechConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpeechConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.customword_.~RepeatedPtrField();
  _impl_.usecustomwordsid_.~RepeatedField();
  _impl_.keywords_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.wordsreplace_;
}

void SpeechConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpeechConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:SpeechConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.customword_.Clear();
  _impl_.usecustomwordsid_.Clear();
  _impl_.keywords_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.wordsreplace_ != nullptr) {
    delete _impl_.wordsreplace_;
  }
  _impl_.wordsreplace_ = nullptr;
  ::memset(&_impl_.lang_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.disablepunctuation_) -
      reinterpret_cast<char*>(&_impl_.lang_)) + sizeof(_impl_.disablepunctuation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeechConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SpeechConfig.Language lang = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_lang(static_cast<::SpeechConfig_Language>(val));
        } else
          goto handle_unusual;
        continue;
      // .SpeechConfig.Scene scene = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_scene(static_cast<::SpeechConfig_Scene>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string customWord = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_customword();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "SpeechConfig.customWord"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 useCustomWordsId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_usecustomwordsid(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_usecustomwordsid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SpeechConfig.RecognizeType recognizeType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_recognizetype(static_cast<::SpeechConfig_RecognizeType>(val));
        } else
          goto handle_unusual;
        continue;
      // bool disableConvertNumber = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.disableconvertnumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool disablePunctuation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.disablepunctuation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .WordsReplace wordsReplace = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wordsreplace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string keyWords = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keywords();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "SpeechConfig.keyWords"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpeechConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SpeechConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SpeechConfig.Language lang = 1;
  if (this->_internal_lang() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_lang(), target);
  }

  // .SpeechConfig.Scene scene = 2;
  if (this->_internal_scene() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_scene(), target);
  }

  // repeated string customWord = 3;
  for (int i = 0, n = this->_internal_customword_size(); i < n; i++) {
    const auto& s = this->_internal_customword(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SpeechConfig.customWord");
    target = stream->WriteString(3, s, target);
  }

  // repeated int32 useCustomWordsId = 4;
  {
    int byte_size = _impl_._usecustomwordsid_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_usecustomwordsid(), byte_size, target);
    }
  }

  // .SpeechConfig.RecognizeType recognizeType = 5;
  if (this->_internal_recognizetype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_recognizetype(), target);
  }

  // bool disableConvertNumber = 6;
  if (this->_internal_disableconvertnumber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_disableconvertnumber(), target);
  }

  // bool disablePunctuation = 7;
  if (this->_internal_disablepunctuation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_disablepunctuation(), target);
  }

  // .WordsReplace wordsReplace = 8;
  if (this->_internal_has_wordsreplace()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::wordsreplace(this),
        _Internal::wordsreplace(this).GetCachedSize(), target, stream);
  }

  // repeated string keyWords = 9;
  for (int i = 0, n = this->_internal_keywords_size(); i < n; i++) {
    const auto& s = this->_internal_keywords(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SpeechConfig.keyWords");
    target = stream->WriteString(9, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SpeechConfig)
  return target;
}

size_t SpeechConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SpeechConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string customWord = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.customword_.size());
  for (int i = 0, n = _impl_.customword_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.customword_.Get(i));
  }

  // repeated int32 useCustomWordsId = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.usecustomwordsid_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._usecustomwordsid_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated string keyWords = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keywords_.size());
  for (int i = 0, n = _impl_.keywords_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.keywords_.Get(i));
  }

  // .WordsReplace wordsReplace = 8;
  if (this->_internal_has_wordsreplace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wordsreplace_);
  }

  // .SpeechConfig.Language lang = 1;
  if (this->_internal_lang() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_lang());
  }

  // .SpeechConfig.Scene scene = 2;
  if (this->_internal_scene() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_scene());
  }

  // .SpeechConfig.RecognizeType recognizeType = 5;
  if (this->_internal_recognizetype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_recognizetype());
  }

  // bool disableConvertNumber = 6;
  if (this->_internal_disableconvertnumber() != 0) {
    total_size += 1 + 1;
  }

  // bool disablePunctuation = 7;
  if (this->_internal_disablepunctuation() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpeechConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpeechConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpeechConfig::GetClassData() const { return &_class_data_; }


void SpeechConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpeechConfig*>(&to_msg);
  auto& from = static_cast<const SpeechConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SpeechConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.customword_.MergeFrom(from._impl_.customword_);
  _this->_impl_.usecustomwordsid_.MergeFrom(from._impl_.usecustomwordsid_);
  _this->_impl_.keywords_.MergeFrom(from._impl_.keywords_);
  if (from._internal_has_wordsreplace()) {
    _this->_internal_mutable_wordsreplace()->::WordsReplace::MergeFrom(
        from._internal_wordsreplace());
  }
  if (from._internal_lang() != 0) {
    _this->_internal_set_lang(from._internal_lang());
  }
  if (from._internal_scene() != 0) {
    _this->_internal_set_scene(from._internal_scene());
  }
  if (from._internal_recognizetype() != 0) {
    _this->_internal_set_recognizetype(from._internal_recognizetype());
  }
  if (from._internal_disableconvertnumber() != 0) {
    _this->_internal_set_disableconvertnumber(from._internal_disableconvertnumber());
  }
  if (from._internal_disablepunctuation() != 0) {
    _this->_internal_set_disablepunctuation(from._internal_disablepunctuation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpeechConfig::CopyFrom(const SpeechConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SpeechConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeechConfig::IsInitialized() const {
  return true;
}

void SpeechConfig::InternalSwap(SpeechConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.customword_.InternalSwap(&other->_impl_.customword_);
  _impl_.usecustomwordsid_.InternalSwap(&other->_impl_.usecustomwordsid_);
  _impl_.keywords_.InternalSwap(&other->_impl_.keywords_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpeechConfig, _impl_.disablepunctuation_)
      + sizeof(SpeechConfig::_impl_.disablepunctuation_)
      - PROTOBUF_FIELD_OFFSET(SpeechConfig, _impl_.wordsreplace_)>(
          reinterpret_cast<char*>(&_impl_.wordsreplace_),
          reinterpret_cast<char*>(&other->_impl_.wordsreplace_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeechConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[1]);
}

// ===================================================================

class WordsReplace::_Internal {
 public:
};

WordsReplace::WordsReplace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:WordsReplace)
}
WordsReplace::WordsReplace(const WordsReplace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WordsReplace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keywords_){from._impl_.keywords_}
    , decltype(_impl_.replace_){from._impl_.replace_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:WordsReplace)
}

inline void WordsReplace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keywords_){arena}
    , decltype(_impl_.replace_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WordsReplace::~WordsReplace() {
  // @@protoc_insertion_point(destructor:WordsReplace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WordsReplace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keywords_.~RepeatedPtrField();
  _impl_.replace_.~RepeatedPtrField();
}

void WordsReplace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WordsReplace::Clear() {
// @@protoc_insertion_point(message_clear_start:WordsReplace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keywords_.Clear();
  _impl_.replace_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WordsReplace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string keywords = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keywords();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "WordsReplace.keywords"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string replace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_replace();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "WordsReplace.replace"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WordsReplace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:WordsReplace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string keywords = 1;
  for (int i = 0, n = this->_internal_keywords_size(); i < n; i++) {
    const auto& s = this->_internal_keywords(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "WordsReplace.keywords");
    target = stream->WriteString(1, s, target);
  }

  // repeated string replace = 2;
  for (int i = 0, n = this->_internal_replace_size(); i < n; i++) {
    const auto& s = this->_internal_replace(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "WordsReplace.replace");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WordsReplace)
  return target;
}

size_t WordsReplace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WordsReplace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string keywords = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keywords_.size());
  for (int i = 0, n = _impl_.keywords_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.keywords_.Get(i));
  }

  // repeated string replace = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.replace_.size());
  for (int i = 0, n = _impl_.replace_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.replace_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WordsReplace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WordsReplace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WordsReplace::GetClassData() const { return &_class_data_; }


void WordsReplace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WordsReplace*>(&to_msg);
  auto& from = static_cast<const WordsReplace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:WordsReplace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keywords_.MergeFrom(from._impl_.keywords_);
  _this->_impl_.replace_.MergeFrom(from._impl_.replace_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WordsReplace::CopyFrom(const WordsReplace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WordsReplace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordsReplace::IsInitialized() const {
  return true;
}

void WordsReplace::InternalSwap(WordsReplace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keywords_.InternalSwap(&other->_impl_.keywords_);
  _impl_.replace_.InternalSwap(&other->_impl_.replace_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WordsReplace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[2]);
}

// ===================================================================

class StreamingSpeechConfig::_Internal {
 public:
  static const ::AudioConfig& audioconfig(const StreamingSpeechConfig* msg);
  static const ::SpeechConfig& speechconfig(const StreamingSpeechConfig* msg);
};

const ::AudioConfig&
StreamingSpeechConfig::_Internal::audioconfig(const StreamingSpeechConfig* msg) {
  return *msg->_impl_.audioconfig_;
}
const ::SpeechConfig&
StreamingSpeechConfig::_Internal::speechconfig(const StreamingSpeechConfig* msg) {
  return *msg->_impl_.speechconfig_;
}
StreamingSpeechConfig::StreamingSpeechConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingSpeechConfig)
}
StreamingSpeechConfig::StreamingSpeechConfig(const StreamingSpeechConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingSpeechConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.audioconfig_){nullptr}
    , decltype(_impl_.speechconfig_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audioconfig()) {
    _this->_impl_.audioconfig_ = new ::AudioConfig(*from._impl_.audioconfig_);
  }
  if (from._internal_has_speechconfig()) {
    _this->_impl_.speechconfig_ = new ::SpeechConfig(*from._impl_.speechconfig_);
  }
  // @@protoc_insertion_point(copy_constructor:StreamingSpeechConfig)
}

inline void StreamingSpeechConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.audioconfig_){nullptr}
    , decltype(_impl_.speechconfig_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamingSpeechConfig::~StreamingSpeechConfig() {
  // @@protoc_insertion_point(destructor:StreamingSpeechConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingSpeechConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audioconfig_;
  if (this != internal_default_instance()) delete _impl_.speechconfig_;
}

void StreamingSpeechConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingSpeechConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingSpeechConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.audioconfig_ != nullptr) {
    delete _impl_.audioconfig_;
  }
  _impl_.audioconfig_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.speechconfig_ != nullptr) {
    delete _impl_.speechconfig_;
  }
  _impl_.speechconfig_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingSpeechConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .AudioConfig audioConfig = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audioconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SpeechConfig speechConfig = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_speechconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingSpeechConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingSpeechConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .AudioConfig audioConfig = 1;
  if (this->_internal_has_audioconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audioconfig(this),
        _Internal::audioconfig(this).GetCachedSize(), target, stream);
  }

  // .SpeechConfig speechConfig = 2;
  if (this->_internal_has_speechconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::speechconfig(this),
        _Internal::speechconfig(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingSpeechConfig)
  return target;
}

size_t StreamingSpeechConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingSpeechConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AudioConfig audioConfig = 1;
  if (this->_internal_has_audioconfig()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audioconfig_);
  }

  // .SpeechConfig speechConfig = 2;
  if (this->_internal_has_speechconfig()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.speechconfig_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingSpeechConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingSpeechConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingSpeechConfig::GetClassData() const { return &_class_data_; }


void StreamingSpeechConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingSpeechConfig*>(&to_msg);
  auto& from = static_cast<const StreamingSpeechConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingSpeechConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_audioconfig()) {
    _this->_internal_mutable_audioconfig()->::AudioConfig::MergeFrom(
        from._internal_audioconfig());
  }
  if (from._internal_has_speechconfig()) {
    _this->_internal_mutable_speechconfig()->::SpeechConfig::MergeFrom(
        from._internal_speechconfig());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingSpeechConfig::CopyFrom(const StreamingSpeechConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingSpeechConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingSpeechConfig::IsInitialized() const {
  return true;
}

void StreamingSpeechConfig::InternalSwap(StreamingSpeechConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamingSpeechConfig, _impl_.speechconfig_)
      + sizeof(StreamingSpeechConfig::_impl_.speechconfig_)
      - PROTOBUF_FIELD_OFFSET(StreamingSpeechConfig, _impl_.audioconfig_)>(
          reinterpret_cast<char*>(&_impl_.audioconfig_),
          reinterpret_cast<char*>(&other->_impl_.audioconfig_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingSpeechConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[3]);
}

// ===================================================================

class StreamingSpeechRequest::_Internal {
 public:
  static const ::StreamingSpeechConfig& streamingspeechconfig(const StreamingSpeechRequest* msg);
};

const ::StreamingSpeechConfig&
StreamingSpeechRequest::_Internal::streamingspeechconfig(const StreamingSpeechRequest* msg) {
  return *msg->_impl_.requestPayload_.streamingspeechconfig_;
}
void StreamingSpeechRequest::set_allocated_streamingspeechconfig(::StreamingSpeechConfig* streamingspeechconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requestPayload();
  if (streamingspeechconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(streamingspeechconfig);
    if (message_arena != submessage_arena) {
      streamingspeechconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streamingspeechconfig, submessage_arena);
    }
    set_has_streamingspeechconfig();
    _impl_.requestPayload_.streamingspeechconfig_ = streamingspeechconfig;
  }
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechRequest.streamingSpeechConfig)
}
StreamingSpeechRequest::StreamingSpeechRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingSpeechRequest)
}
StreamingSpeechRequest::StreamingSpeechRequest(const StreamingSpeechRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingSpeechRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requestPayload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_requestPayload();
  switch (from.requestPayload_case()) {
    case kStreamingSpeechConfig: {
      _this->_internal_mutable_streamingspeechconfig()->::StreamingSpeechConfig::MergeFrom(
          from._internal_streamingspeechconfig());
      break;
    }
    case kAudioData: {
      _this->_internal_set_audiodata(from._internal_audiodata());
      break;
    }
    case REQUESTPAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:StreamingSpeechRequest)
}

inline void StreamingSpeechRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requestPayload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_requestPayload();
}

StreamingSpeechRequest::~StreamingSpeechRequest() {
  // @@protoc_insertion_point(destructor:StreamingSpeechRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingSpeechRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_requestPayload()) {
    clear_requestPayload();
  }
}

void StreamingSpeechRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingSpeechRequest::clear_requestPayload() {
// @@protoc_insertion_point(one_of_clear_start:StreamingSpeechRequest)
  switch (requestPayload_case()) {
    case kStreamingSpeechConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requestPayload_.streamingspeechconfig_;
      }
      break;
    }
    case kAudioData: {
      _impl_.requestPayload_.audiodata_.Destroy();
      break;
    }
    case REQUESTPAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUESTPAYLOAD_NOT_SET;
}


void StreamingSpeechRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingSpeechRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_requestPayload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingSpeechRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .StreamingSpeechConfig streamingSpeechConfig = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_streamingspeechconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes audioData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_audiodata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingSpeechRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingSpeechRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .StreamingSpeechConfig streamingSpeechConfig = 1;
  if (_internal_has_streamingspeechconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::streamingspeechconfig(this),
        _Internal::streamingspeechconfig(this).GetCachedSize(), target, stream);
  }

  // bytes audioData = 2;
  if (_internal_has_audiodata()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_audiodata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingSpeechRequest)
  return target;
}

size_t StreamingSpeechRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingSpeechRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (requestPayload_case()) {
    // .StreamingSpeechConfig streamingSpeechConfig = 1;
    case kStreamingSpeechConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requestPayload_.streamingspeechconfig_);
      break;
    }
    // bytes audioData = 2;
    case kAudioData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audiodata());
      break;
    }
    case REQUESTPAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingSpeechRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingSpeechRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingSpeechRequest::GetClassData() const { return &_class_data_; }


void StreamingSpeechRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingSpeechRequest*>(&to_msg);
  auto& from = static_cast<const StreamingSpeechRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingSpeechRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.requestPayload_case()) {
    case kStreamingSpeechConfig: {
      _this->_internal_mutable_streamingspeechconfig()->::StreamingSpeechConfig::MergeFrom(
          from._internal_streamingspeechconfig());
      break;
    }
    case kAudioData: {
      _this->_internal_set_audiodata(from._internal_audiodata());
      break;
    }
    case REQUESTPAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingSpeechRequest::CopyFrom(const StreamingSpeechRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingSpeechRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingSpeechRequest::IsInitialized() const {
  return true;
}

void StreamingSpeechRequest::InternalSwap(StreamingSpeechRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.requestPayload_, other->_impl_.requestPayload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingSpeechRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[4]);
}

// ===================================================================

class StreamingSpeechResponse::_Internal {
 public:
  static const ::StreamingSpeechResult& result(const StreamingSpeechResponse* msg);
  static const ::StreamingSpeechStatus& status(const StreamingSpeechResponse* msg);
};

const ::StreamingSpeechResult&
StreamingSpeechResponse::_Internal::result(const StreamingSpeechResponse* msg) {
  return *msg->_impl_.result_;
}
const ::StreamingSpeechStatus&
StreamingSpeechResponse::_Internal::status(const StreamingSpeechResponse* msg) {
  return *msg->_impl_.status_;
}
StreamingSpeechResponse::StreamingSpeechResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingSpeechResponse)
}
StreamingSpeechResponse::StreamingSpeechResponse(const StreamingSpeechResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingSpeechResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.globalstreamid_){}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.globalstreamid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.globalstreamid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_globalstreamid().empty()) {
    _this->_impl_.globalstreamid_.Set(from._internal_globalstreamid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::StreamingSpeechResult(*from._impl_.result_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::StreamingSpeechStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:StreamingSpeechResponse)
}

inline void StreamingSpeechResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.globalstreamid_){}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.globalstreamid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.globalstreamid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamingSpeechResponse::~StreamingSpeechResponse() {
  // @@protoc_insertion_point(destructor:StreamingSpeechResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingSpeechResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.globalstreamid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.result_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void StreamingSpeechResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingSpeechResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingSpeechResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.globalstreamid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingSpeechResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string globalStreamId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_globalstreamid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "StreamingSpeechResponse.globalStreamId"));
        } else
          goto handle_unusual;
        continue;
      // .StreamingSpeechResult result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StreamingSpeechStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingSpeechResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingSpeechResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string globalStreamId = 1;
  if (!this->_internal_globalstreamid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_globalstreamid().data(), static_cast<int>(this->_internal_globalstreamid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "StreamingSpeechResponse.globalStreamId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_globalstreamid(), target);
  }

  // .StreamingSpeechResult result = 2;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  // .StreamingSpeechStatus status = 3;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingSpeechResponse)
  return target;
}

size_t StreamingSpeechResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingSpeechResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string globalStreamId = 1;
  if (!this->_internal_globalstreamid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_globalstreamid());
  }

  // .StreamingSpeechResult result = 2;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // .StreamingSpeechStatus status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingSpeechResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingSpeechResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingSpeechResponse::GetClassData() const { return &_class_data_; }


void StreamingSpeechResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingSpeechResponse*>(&to_msg);
  auto& from = static_cast<const StreamingSpeechResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingSpeechResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_globalstreamid().empty()) {
    _this->_internal_set_globalstreamid(from._internal_globalstreamid());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::StreamingSpeechResult::MergeFrom(
        from._internal_result());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::StreamingSpeechStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingSpeechResponse::CopyFrom(const StreamingSpeechResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingSpeechResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingSpeechResponse::IsInitialized() const {
  return true;
}

void StreamingSpeechResponse::InternalSwap(StreamingSpeechResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.globalstreamid_, lhs_arena,
      &other->_impl_.globalstreamid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamingSpeechResponse, _impl_.status_)
      + sizeof(StreamingSpeechResponse::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(StreamingSpeechResponse, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingSpeechResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[5]);
}

// ===================================================================

class StreamingSpeechResult::_Internal {
 public:
  static const ::StreamingTranscription& besttranscription(const StreamingSpeechResult* msg);
};

const ::StreamingTranscription&
StreamingSpeechResult::_Internal::besttranscription(const StreamingSpeechResult* msg) {
  return *msg->_impl_.besttranscription_;
}
StreamingSpeechResult::StreamingSpeechResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingSpeechResult)
}
StreamingSpeechResult::StreamingSpeechResult(const StreamingSpeechResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingSpeechResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.besttranscription_){nullptr}
    , decltype(_impl_.isfinal_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_besttranscription()) {
    _this->_impl_.besttranscription_ = new ::StreamingTranscription(*from._impl_.besttranscription_);
  }
  _this->_impl_.isfinal_ = from._impl_.isfinal_;
  // @@protoc_insertion_point(copy_constructor:StreamingSpeechResult)
}

inline void StreamingSpeechResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.besttranscription_){nullptr}
    , decltype(_impl_.isfinal_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamingSpeechResult::~StreamingSpeechResult() {
  // @@protoc_insertion_point(destructor:StreamingSpeechResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingSpeechResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.besttranscription_;
}

void StreamingSpeechResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingSpeechResult::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingSpeechResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.besttranscription_ != nullptr) {
    delete _impl_.besttranscription_;
  }
  _impl_.besttranscription_ = nullptr;
  _impl_.isfinal_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingSpeechResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isFinal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isfinal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StreamingTranscription bestTranscription = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_besttranscription(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingSpeechResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingSpeechResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isFinal = 1;
  if (this->_internal_isfinal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isfinal(), target);
  }

  // .StreamingTranscription bestTranscription = 2;
  if (this->_internal_has_besttranscription()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::besttranscription(this),
        _Internal::besttranscription(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingSpeechResult)
  return target;
}

size_t StreamingSpeechResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingSpeechResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .StreamingTranscription bestTranscription = 2;
  if (this->_internal_has_besttranscription()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.besttranscription_);
  }

  // bool isFinal = 1;
  if (this->_internal_isfinal() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingSpeechResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingSpeechResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingSpeechResult::GetClassData() const { return &_class_data_; }


void StreamingSpeechResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingSpeechResult*>(&to_msg);
  auto& from = static_cast<const StreamingSpeechResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingSpeechResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_besttranscription()) {
    _this->_internal_mutable_besttranscription()->::StreamingTranscription::MergeFrom(
        from._internal_besttranscription());
  }
  if (from._internal_isfinal() != 0) {
    _this->_internal_set_isfinal(from._internal_isfinal());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingSpeechResult::CopyFrom(const StreamingSpeechResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingSpeechResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingSpeechResult::IsInitialized() const {
  return true;
}

void StreamingSpeechResult::InternalSwap(StreamingSpeechResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamingSpeechResult, _impl_.isfinal_)
      + sizeof(StreamingSpeechResult::_impl_.isfinal_)
      - PROTOBUF_FIELD_OFFSET(StreamingSpeechResult, _impl_.besttranscription_)>(
          reinterpret_cast<char*>(&_impl_.besttranscription_),
          reinterpret_cast<char*>(&other->_impl_.besttranscription_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingSpeechResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[6]);
}

// ===================================================================

class StreamingSpeechStatus::_Internal {
 public:
};

StreamingSpeechStatus::StreamingSpeechStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingSpeechStatus)
}
StreamingSpeechStatus::StreamingSpeechStatus(const StreamingSpeechStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingSpeechStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.processedtimestamp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.processedtimestamp_ = from._impl_.processedtimestamp_;
  // @@protoc_insertion_point(copy_constructor:StreamingSpeechStatus)
}

inline void StreamingSpeechStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.processedtimestamp_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamingSpeechStatus::~StreamingSpeechStatus() {
  // @@protoc_insertion_point(destructor:StreamingSpeechStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingSpeechStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StreamingSpeechStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingSpeechStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingSpeechStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.processedtimestamp_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingSpeechStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 processedTimestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.processedtimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingSpeechStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingSpeechStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 processedTimestamp = 1;
  if (this->_internal_processedtimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_processedtimestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingSpeechStatus)
  return target;
}

size_t StreamingSpeechStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingSpeechStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 processedTimestamp = 1;
  if (this->_internal_processedtimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_processedtimestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingSpeechStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingSpeechStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingSpeechStatus::GetClassData() const { return &_class_data_; }


void StreamingSpeechStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingSpeechStatus*>(&to_msg);
  auto& from = static_cast<const StreamingSpeechStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingSpeechStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_processedtimestamp() != 0) {
    _this->_internal_set_processedtimestamp(from._internal_processedtimestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingSpeechStatus::CopyFrom(const StreamingSpeechStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingSpeechStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingSpeechStatus::IsInitialized() const {
  return true;
}

void StreamingSpeechStatus::InternalSwap(StreamingSpeechStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.processedtimestamp_, other->_impl_.processedtimestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingSpeechStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[7]);
}

// ===================================================================

class StreamingTranscription::_Internal {
 public:
};

StreamingTranscription::StreamingTranscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingTranscription)
}
StreamingTranscription::StreamingTranscription(const StreamingTranscription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingTranscription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keywordstype_){from._impl_.keywordstype_}
    , decltype(_impl_.piece_){from._impl_.piece_}
    , decltype(_impl_.transcribedtext_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcribedtext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcribedtext().empty()) {
    _this->_impl_.transcribedtext_.Set(from._internal_transcribedtext(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:StreamingTranscription)
}

inline void StreamingTranscription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keywordstype_){arena}
    , decltype(_impl_.piece_){arena}
    , decltype(_impl_.transcribedtext_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcribedtext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamingTranscription::~StreamingTranscription() {
  // @@protoc_insertion_point(destructor:StreamingTranscription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingTranscription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keywordstype_.~RepeatedPtrField();
  _impl_.piece_.~RepeatedPtrField();
  _impl_.transcribedtext_.Destroy();
}

void StreamingTranscription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingTranscription::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingTranscription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keywordstype_.Clear();
  _impl_.piece_.Clear();
  _impl_.transcribedtext_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingTranscription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcribedText = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcribedtext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "StreamingTranscription.transcribedText"));
        } else
          goto handle_unusual;
        continue;
      // repeated .KeyWordsType keyWordsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keywordstype(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StreamingTranscriptionPiece piece = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingTranscription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingTranscription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcribedText = 1;
  if (!this->_internal_transcribedtext().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcribedtext().data(), static_cast<int>(this->_internal_transcribedtext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "StreamingTranscription.transcribedText");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcribedtext(), target);
  }

  // repeated .KeyWordsType keyWordsType = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keywordstype_size()); i < n; i++) {
    const auto& repfield = this->_internal_keywordstype(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .StreamingTranscriptionPiece piece = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingTranscription)
  return target;
}

size_t StreamingTranscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingTranscription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .KeyWordsType keyWordsType = 2;
  total_size += 1UL * this->_internal_keywordstype_size();
  for (const auto& msg : this->_impl_.keywordstype_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StreamingTranscriptionPiece piece = 3;
  total_size += 1UL * this->_internal_piece_size();
  for (const auto& msg : this->_impl_.piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string transcribedText = 1;
  if (!this->_internal_transcribedtext().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcribedtext());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingTranscription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingTranscription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingTranscription::GetClassData() const { return &_class_data_; }


void StreamingTranscription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingTranscription*>(&to_msg);
  auto& from = static_cast<const StreamingTranscription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingTranscription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keywordstype_.MergeFrom(from._impl_.keywordstype_);
  _this->_impl_.piece_.MergeFrom(from._impl_.piece_);
  if (!from._internal_transcribedtext().empty()) {
    _this->_internal_set_transcribedtext(from._internal_transcribedtext());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingTranscription::CopyFrom(const StreamingTranscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingTranscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingTranscription::IsInitialized() const {
  return true;
}

void StreamingTranscription::InternalSwap(StreamingTranscription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keywordstype_.InternalSwap(&other->_impl_.keywordstype_);
  _impl_.piece_.InternalSwap(&other->_impl_.piece_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcribedtext_, lhs_arena,
      &other->_impl_.transcribedtext_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingTranscription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[8]);
}

// ===================================================================

class KeyWordsType::_Internal {
 public:
};

KeyWordsType::KeyWordsType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:KeyWordsType)
}
KeyWordsType::KeyWordsType(const KeyWordsType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyWordsType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keywords_){}
    , decltype(_impl_.keywordsscore_){}
    , decltype(_impl_.starttimestamp_){}
    , decltype(_impl_.endtimestamp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.keywords_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keywords_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_keywords().empty()) {
    _this->_impl_.keywords_.Set(from._internal_keywords(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.keywordsscore_, &from._impl_.keywordsscore_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endtimestamp_) -
    reinterpret_cast<char*>(&_impl_.keywordsscore_)) + sizeof(_impl_.endtimestamp_));
  // @@protoc_insertion_point(copy_constructor:KeyWordsType)
}

inline void KeyWordsType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keywords_){}
    , decltype(_impl_.keywordsscore_){0}
    , decltype(_impl_.starttimestamp_){0}
    , decltype(_impl_.endtimestamp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.keywords_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keywords_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyWordsType::~KeyWordsType() {
  // @@protoc_insertion_point(destructor:KeyWordsType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyWordsType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keywords_.Destroy();
}

void KeyWordsType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyWordsType::Clear() {
// @@protoc_insertion_point(message_clear_start:KeyWordsType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keywords_.ClearToEmpty();
  ::memset(&_impl_.keywordsscore_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.endtimestamp_) -
      reinterpret_cast<char*>(&_impl_.keywordsscore_)) + sizeof(_impl_.endtimestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyWordsType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string keyWords = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_keywords();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "KeyWordsType.keyWords"));
        } else
          goto handle_unusual;
        continue;
      // float keyWordsScore = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.keywordsscore_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 startTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.starttimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 endTimestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.endtimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyWordsType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KeyWordsType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string keyWords = 1;
  if (!this->_internal_keywords().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keywords().data(), static_cast<int>(this->_internal_keywords().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "KeyWordsType.keyWords");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_keywords(), target);
  }

  // float keyWordsScore = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_keywordsscore = this->_internal_keywordsscore();
  uint32_t raw_keywordsscore;
  memcpy(&raw_keywordsscore, &tmp_keywordsscore, sizeof(tmp_keywordsscore));
  if (raw_keywordsscore != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_keywordsscore(), target);
  }

  // int32 startTimestamp = 3;
  if (this->_internal_starttimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_starttimestamp(), target);
  }

  // int32 endTimestamp = 4;
  if (this->_internal_endtimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_endtimestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KeyWordsType)
  return target;
}

size_t KeyWordsType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KeyWordsType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyWords = 1;
  if (!this->_internal_keywords().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keywords());
  }

  // float keyWordsScore = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_keywordsscore = this->_internal_keywordsscore();
  uint32_t raw_keywordsscore;
  memcpy(&raw_keywordsscore, &tmp_keywordsscore, sizeof(tmp_keywordsscore));
  if (raw_keywordsscore != 0) {
    total_size += 1 + 4;
  }

  // int32 startTimestamp = 3;
  if (this->_internal_starttimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_starttimestamp());
  }

  // int32 endTimestamp = 4;
  if (this->_internal_endtimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_endtimestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyWordsType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyWordsType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyWordsType::GetClassData() const { return &_class_data_; }


void KeyWordsType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyWordsType*>(&to_msg);
  auto& from = static_cast<const KeyWordsType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:KeyWordsType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keywords().empty()) {
    _this->_internal_set_keywords(from._internal_keywords());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_keywordsscore = from._internal_keywordsscore();
  uint32_t raw_keywordsscore;
  memcpy(&raw_keywordsscore, &tmp_keywordsscore, sizeof(tmp_keywordsscore));
  if (raw_keywordsscore != 0) {
    _this->_internal_set_keywordsscore(from._internal_keywordsscore());
  }
  if (from._internal_starttimestamp() != 0) {
    _this->_internal_set_starttimestamp(from._internal_starttimestamp());
  }
  if (from._internal_endtimestamp() != 0) {
    _this->_internal_set_endtimestamp(from._internal_endtimestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyWordsType::CopyFrom(const KeyWordsType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KeyWordsType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyWordsType::IsInitialized() const {
  return true;
}

void KeyWordsType::InternalSwap(KeyWordsType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.keywords_, lhs_arena,
      &other->_impl_.keywords_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyWordsType, _impl_.endtimestamp_)
      + sizeof(KeyWordsType::_impl_.endtimestamp_)
      - PROTOBUF_FIELD_OFFSET(KeyWordsType, _impl_.keywordsscore_)>(
          reinterpret_cast<char*>(&_impl_.keywordsscore_),
          reinterpret_cast<char*>(&other->_impl_.keywordsscore_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyWordsType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[9]);
}

// ===================================================================

class StreamingTranscriptionPiece::_Internal {
 public:
};

StreamingTranscriptionPiece::StreamingTranscriptionPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamingTranscriptionPiece)
}
StreamingTranscriptionPiece::StreamingTranscriptionPiece(const StreamingTranscriptionPiece& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamingTranscriptionPiece* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transcribedtext_){}
    , decltype(_impl_.begintimestamp_){}
    , decltype(_impl_.endtimestamp_){}
    , decltype(_impl_.transcribedtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcribedtext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcribedtext().empty()) {
    _this->_impl_.transcribedtext_.Set(from._internal_transcribedtext(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.begintimestamp_, &from._impl_.begintimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.transcribedtype_) -
    reinterpret_cast<char*>(&_impl_.begintimestamp_)) + sizeof(_impl_.transcribedtype_));
  // @@protoc_insertion_point(copy_constructor:StreamingTranscriptionPiece)
}

inline void StreamingTranscriptionPiece::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transcribedtext_){}
    , decltype(_impl_.begintimestamp_){int64_t{0}}
    , decltype(_impl_.endtimestamp_){int64_t{0}}
    , decltype(_impl_.transcribedtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcribedtext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamingTranscriptionPiece::~StreamingTranscriptionPiece() {
  // @@protoc_insertion_point(destructor:StreamingTranscriptionPiece)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamingTranscriptionPiece::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transcribedtext_.Destroy();
}

void StreamingTranscriptionPiece::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamingTranscriptionPiece::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamingTranscriptionPiece)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transcribedtext_.ClearToEmpty();
  ::memset(&_impl_.begintimestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.transcribedtype_) -
      reinterpret_cast<char*>(&_impl_.begintimestamp_)) + sizeof(_impl_.transcribedtype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamingTranscriptionPiece::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcribedText = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcribedtext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "StreamingTranscriptionPiece.transcribedText"));
        } else
          goto handle_unusual;
        continue;
      // int64 beginTimestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.begintimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 endTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.endtimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 transcribedType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.transcribedtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamingTranscriptionPiece::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamingTranscriptionPiece)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcribedText = 1;
  if (!this->_internal_transcribedtext().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcribedtext().data(), static_cast<int>(this->_internal_transcribedtext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "StreamingTranscriptionPiece.transcribedText");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcribedtext(), target);
  }

  // int64 beginTimestamp = 2;
  if (this->_internal_begintimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_begintimestamp(), target);
  }

  // int64 endTimestamp = 3;
  if (this->_internal_endtimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_endtimestamp(), target);
  }

  // int32 transcribedType = 4;
  if (this->_internal_transcribedtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_transcribedtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamingTranscriptionPiece)
  return target;
}

size_t StreamingTranscriptionPiece::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamingTranscriptionPiece)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transcribedText = 1;
  if (!this->_internal_transcribedtext().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcribedtext());
  }

  // int64 beginTimestamp = 2;
  if (this->_internal_begintimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_begintimestamp());
  }

  // int64 endTimestamp = 3;
  if (this->_internal_endtimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_endtimestamp());
  }

  // int32 transcribedType = 4;
  if (this->_internal_transcribedtype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_transcribedtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamingTranscriptionPiece::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamingTranscriptionPiece::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamingTranscriptionPiece::GetClassData() const { return &_class_data_; }


void StreamingTranscriptionPiece::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamingTranscriptionPiece*>(&to_msg);
  auto& from = static_cast<const StreamingTranscriptionPiece&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamingTranscriptionPiece)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transcribedtext().empty()) {
    _this->_internal_set_transcribedtext(from._internal_transcribedtext());
  }
  if (from._internal_begintimestamp() != 0) {
    _this->_internal_set_begintimestamp(from._internal_begintimestamp());
  }
  if (from._internal_endtimestamp() != 0) {
    _this->_internal_set_endtimestamp(from._internal_endtimestamp());
  }
  if (from._internal_transcribedtype() != 0) {
    _this->_internal_set_transcribedtype(from._internal_transcribedtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamingTranscriptionPiece::CopyFrom(const StreamingTranscriptionPiece& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamingTranscriptionPiece)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamingTranscriptionPiece::IsInitialized() const {
  return true;
}

void StreamingTranscriptionPiece::InternalSwap(StreamingTranscriptionPiece* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcribedtext_, lhs_arena,
      &other->_impl_.transcribedtext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamingTranscriptionPiece, _impl_.transcribedtype_)
      + sizeof(StreamingTranscriptionPiece::_impl_.transcribedtype_)
      - PROTOBUF_FIELD_OFFSET(StreamingTranscriptionPiece, _impl_.begintimestamp_)>(
          reinterpret_cast<char*>(&_impl_.begintimestamp_),
          reinterpret_cast<char*>(&other->_impl_.begintimestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamingTranscriptionPiece::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_yitu_5fstreaming_2eproto_getter, &descriptor_table_yitu_5fstreaming_2eproto_once,
      file_level_metadata_yitu_5fstreaming_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AudioConfig*
Arena::CreateMaybeMessage< ::AudioConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AudioConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::SpeechConfig*
Arena::CreateMaybeMessage< ::SpeechConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SpeechConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::WordsReplace*
Arena::CreateMaybeMessage< ::WordsReplace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::WordsReplace >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingSpeechConfig*
Arena::CreateMaybeMessage< ::StreamingSpeechConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingSpeechConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingSpeechRequest*
Arena::CreateMaybeMessage< ::StreamingSpeechRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingSpeechRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingSpeechResponse*
Arena::CreateMaybeMessage< ::StreamingSpeechResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingSpeechResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingSpeechResult*
Arena::CreateMaybeMessage< ::StreamingSpeechResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingSpeechResult >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingSpeechStatus*
Arena::CreateMaybeMessage< ::StreamingSpeechStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingSpeechStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingTranscription*
Arena::CreateMaybeMessage< ::StreamingTranscription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingTranscription >(arena);
}
template<> PROTOBUF_NOINLINE ::KeyWordsType*
Arena::CreateMaybeMessage< ::KeyWordsType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KeyWordsType >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamingTranscriptionPiece*
Arena::CreateMaybeMessage< ::StreamingTranscriptionPiece >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamingTranscriptionPiece >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
