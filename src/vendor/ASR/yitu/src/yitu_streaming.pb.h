// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yitu_streaming.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_yitu_5fstreaming_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_yitu_5fstreaming_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_yitu_5fstreaming_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_yitu_5fstreaming_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_yitu_5fstreaming_2eproto;
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class KeyWordsType;
struct KeyWordsTypeDefaultTypeInternal;
extern KeyWordsTypeDefaultTypeInternal _KeyWordsType_default_instance_;
class SpeechConfig;
struct SpeechConfigDefaultTypeInternal;
extern SpeechConfigDefaultTypeInternal _SpeechConfig_default_instance_;
class StreamingSpeechConfig;
struct StreamingSpeechConfigDefaultTypeInternal;
extern StreamingSpeechConfigDefaultTypeInternal _StreamingSpeechConfig_default_instance_;
class StreamingSpeechRequest;
struct StreamingSpeechRequestDefaultTypeInternal;
extern StreamingSpeechRequestDefaultTypeInternal _StreamingSpeechRequest_default_instance_;
class StreamingSpeechResponse;
struct StreamingSpeechResponseDefaultTypeInternal;
extern StreamingSpeechResponseDefaultTypeInternal _StreamingSpeechResponse_default_instance_;
class StreamingSpeechResult;
struct StreamingSpeechResultDefaultTypeInternal;
extern StreamingSpeechResultDefaultTypeInternal _StreamingSpeechResult_default_instance_;
class StreamingSpeechStatus;
struct StreamingSpeechStatusDefaultTypeInternal;
extern StreamingSpeechStatusDefaultTypeInternal _StreamingSpeechStatus_default_instance_;
class StreamingTranscription;
struct StreamingTranscriptionDefaultTypeInternal;
extern StreamingTranscriptionDefaultTypeInternal _StreamingTranscription_default_instance_;
class StreamingTranscriptionPiece;
struct StreamingTranscriptionPieceDefaultTypeInternal;
extern StreamingTranscriptionPieceDefaultTypeInternal _StreamingTranscriptionPiece_default_instance_;
class WordsReplace;
struct WordsReplaceDefaultTypeInternal;
extern WordsReplaceDefaultTypeInternal _WordsReplace_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AudioConfig* Arena::CreateMaybeMessage<::AudioConfig>(Arena*);
template<> ::KeyWordsType* Arena::CreateMaybeMessage<::KeyWordsType>(Arena*);
template<> ::SpeechConfig* Arena::CreateMaybeMessage<::SpeechConfig>(Arena*);
template<> ::StreamingSpeechConfig* Arena::CreateMaybeMessage<::StreamingSpeechConfig>(Arena*);
template<> ::StreamingSpeechRequest* Arena::CreateMaybeMessage<::StreamingSpeechRequest>(Arena*);
template<> ::StreamingSpeechResponse* Arena::CreateMaybeMessage<::StreamingSpeechResponse>(Arena*);
template<> ::StreamingSpeechResult* Arena::CreateMaybeMessage<::StreamingSpeechResult>(Arena*);
template<> ::StreamingSpeechStatus* Arena::CreateMaybeMessage<::StreamingSpeechStatus>(Arena*);
template<> ::StreamingTranscription* Arena::CreateMaybeMessage<::StreamingTranscription>(Arena*);
template<> ::StreamingTranscriptionPiece* Arena::CreateMaybeMessage<::StreamingTranscriptionPiece>(Arena*);
template<> ::WordsReplace* Arena::CreateMaybeMessage<::WordsReplace>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum AudioConfig_AudioEncoding : int {
  AudioConfig_AudioEncoding_UNSPECIFIED = 0,
  AudioConfig_AudioEncoding_PCM = 1,
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioConfig_AudioEncoding_IsValid(int value);
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MIN = AudioConfig_AudioEncoding_UNSPECIFIED;
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MAX = AudioConfig_AudioEncoding_PCM;
constexpr int AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE = AudioConfig_AudioEncoding_AudioEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioConfig_AudioEncoding_descriptor();
template<typename T>
inline const std::string& AudioConfig_AudioEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioConfig_AudioEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioConfig_AudioEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioConfig_AudioEncoding_descriptor(), enum_t_value);
}
inline bool AudioConfig_AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioConfig_AudioEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioConfig_AudioEncoding>(
    AudioConfig_AudioEncoding_descriptor(), name, value);
}
enum SpeechConfig_Language : int {
  SpeechConfig_Language_UNSPECIFIED = 0,
  SpeechConfig_Language_MANDARIN = 1,
  SpeechConfig_Language_ENGLISH = 2,
  SpeechConfig_Language_SpeechConfig_Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpeechConfig_Language_SpeechConfig_Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpeechConfig_Language_IsValid(int value);
constexpr SpeechConfig_Language SpeechConfig_Language_Language_MIN = SpeechConfig_Language_UNSPECIFIED;
constexpr SpeechConfig_Language SpeechConfig_Language_Language_MAX = SpeechConfig_Language_ENGLISH;
constexpr int SpeechConfig_Language_Language_ARRAYSIZE = SpeechConfig_Language_Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_Language_descriptor();
template<typename T>
inline const std::string& SpeechConfig_Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeechConfig_Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeechConfig_Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeechConfig_Language_descriptor(), enum_t_value);
}
inline bool SpeechConfig_Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpeechConfig_Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeechConfig_Language>(
    SpeechConfig_Language_descriptor(), name, value);
}
enum SpeechConfig_Scene : int {
  SpeechConfig_Scene_GENERALSCENE = 0,
  SpeechConfig_Scene_SpeechConfig_Scene_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpeechConfig_Scene_SpeechConfig_Scene_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpeechConfig_Scene_IsValid(int value);
constexpr SpeechConfig_Scene SpeechConfig_Scene_Scene_MIN = SpeechConfig_Scene_GENERALSCENE;
constexpr SpeechConfig_Scene SpeechConfig_Scene_Scene_MAX = SpeechConfig_Scene_GENERALSCENE;
constexpr int SpeechConfig_Scene_Scene_ARRAYSIZE = SpeechConfig_Scene_Scene_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_Scene_descriptor();
template<typename T>
inline const std::string& SpeechConfig_Scene_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeechConfig_Scene>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeechConfig_Scene_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeechConfig_Scene_descriptor(), enum_t_value);
}
inline bool SpeechConfig_Scene_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpeechConfig_Scene* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeechConfig_Scene>(
    SpeechConfig_Scene_descriptor(), name, value);
}
enum SpeechConfig_RecognizeType : int {
  SpeechConfig_RecognizeType_ALL = 0,
  SpeechConfig_RecognizeType_UTTERANCE = 1,
  SpeechConfig_RecognizeType_STREAMING = 2,
  SpeechConfig_RecognizeType_SpeechConfig_RecognizeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpeechConfig_RecognizeType_SpeechConfig_RecognizeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpeechConfig_RecognizeType_IsValid(int value);
constexpr SpeechConfig_RecognizeType SpeechConfig_RecognizeType_RecognizeType_MIN = SpeechConfig_RecognizeType_ALL;
constexpr SpeechConfig_RecognizeType SpeechConfig_RecognizeType_RecognizeType_MAX = SpeechConfig_RecognizeType_STREAMING;
constexpr int SpeechConfig_RecognizeType_RecognizeType_ARRAYSIZE = SpeechConfig_RecognizeType_RecognizeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeechConfig_RecognizeType_descriptor();
template<typename T>
inline const std::string& SpeechConfig_RecognizeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeechConfig_RecognizeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeechConfig_RecognizeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeechConfig_RecognizeType_descriptor(), enum_t_value);
}
inline bool SpeechConfig_RecognizeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpeechConfig_RecognizeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeechConfig_RecognizeType>(
    SpeechConfig_RecognizeType_descriptor(), name, value);
}
// ===================================================================

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioConfig& from) {
    AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AudioConfig_AudioEncoding AudioEncoding;
  static constexpr AudioEncoding UNSPECIFIED =
    AudioConfig_AudioEncoding_UNSPECIFIED;
  static constexpr AudioEncoding PCM =
    AudioConfig_AudioEncoding_PCM;
  static inline bool AudioEncoding_IsValid(int value) {
    return AudioConfig_AudioEncoding_IsValid(value);
  }
  static constexpr AudioEncoding AudioEncoding_MIN =
    AudioConfig_AudioEncoding_AudioEncoding_MIN;
  static constexpr AudioEncoding AudioEncoding_MAX =
    AudioConfig_AudioEncoding_AudioEncoding_MAX;
  static constexpr int AudioEncoding_ARRAYSIZE =
    AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioEncoding_descriptor() {
    return AudioConfig_AudioEncoding_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioEncoding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioEncoding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioEncoding_Name.");
    return AudioConfig_AudioEncoding_Name(enum_t_value);
  }
  static inline bool AudioEncoding_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioEncoding* value) {
    return AudioConfig_AudioEncoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAueFieldNumber = 1,
    kSampleRateFieldNumber = 8000,
  };
  // .AudioConfig.AudioEncoding aue = 1;
  void clear_aue();
  ::AudioConfig_AudioEncoding aue() const;
  void set_aue(::AudioConfig_AudioEncoding value);
  private:
  ::AudioConfig_AudioEncoding _internal_aue() const;
  void _internal_set_aue(::AudioConfig_AudioEncoding value);
  public:

  // int32 sampleRate = 8000;
  void clear_samplerate();
  int32_t samplerate() const;
  void set_samplerate(int32_t value);
  private:
  int32_t _internal_samplerate() const;
  void _internal_set_samplerate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int aue_;
    int32_t samplerate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class SpeechConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpeechConfig) */ {
 public:
  inline SpeechConfig() : SpeechConfig(nullptr) {}
  ~SpeechConfig() override;
  explicit PROTOBUF_CONSTEXPR SpeechConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeechConfig(const SpeechConfig& from);
  SpeechConfig(SpeechConfig&& from) noexcept
    : SpeechConfig() {
    *this = ::std::move(from);
  }

  inline SpeechConfig& operator=(const SpeechConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechConfig& operator=(SpeechConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechConfig* internal_default_instance() {
    return reinterpret_cast<const SpeechConfig*>(
               &_SpeechConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpeechConfig& a, SpeechConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeechConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeechConfig& from) {
    SpeechConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpeechConfig";
  }
  protected:
  explicit SpeechConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SpeechConfig_Language Language;
  static constexpr Language UNSPECIFIED =
    SpeechConfig_Language_UNSPECIFIED;
  static constexpr Language MANDARIN =
    SpeechConfig_Language_MANDARIN;
  static constexpr Language ENGLISH =
    SpeechConfig_Language_ENGLISH;
  static inline bool Language_IsValid(int value) {
    return SpeechConfig_Language_IsValid(value);
  }
  static constexpr Language Language_MIN =
    SpeechConfig_Language_Language_MIN;
  static constexpr Language Language_MAX =
    SpeechConfig_Language_Language_MAX;
  static constexpr int Language_ARRAYSIZE =
    SpeechConfig_Language_Language_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Language_descriptor() {
    return SpeechConfig_Language_descriptor();
  }
  template<typename T>
  static inline const std::string& Language_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Language>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Language_Name.");
    return SpeechConfig_Language_Name(enum_t_value);
  }
  static inline bool Language_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Language* value) {
    return SpeechConfig_Language_Parse(name, value);
  }

  typedef SpeechConfig_Scene Scene;
  static constexpr Scene GENERALSCENE =
    SpeechConfig_Scene_GENERALSCENE;
  static inline bool Scene_IsValid(int value) {
    return SpeechConfig_Scene_IsValid(value);
  }
  static constexpr Scene Scene_MIN =
    SpeechConfig_Scene_Scene_MIN;
  static constexpr Scene Scene_MAX =
    SpeechConfig_Scene_Scene_MAX;
  static constexpr int Scene_ARRAYSIZE =
    SpeechConfig_Scene_Scene_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Scene_descriptor() {
    return SpeechConfig_Scene_descriptor();
  }
  template<typename T>
  static inline const std::string& Scene_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Scene>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Scene_Name.");
    return SpeechConfig_Scene_Name(enum_t_value);
  }
  static inline bool Scene_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Scene* value) {
    return SpeechConfig_Scene_Parse(name, value);
  }

  typedef SpeechConfig_RecognizeType RecognizeType;
  static constexpr RecognizeType ALL =
    SpeechConfig_RecognizeType_ALL;
  static constexpr RecognizeType UTTERANCE =
    SpeechConfig_RecognizeType_UTTERANCE;
  static constexpr RecognizeType STREAMING =
    SpeechConfig_RecognizeType_STREAMING;
  static inline bool RecognizeType_IsValid(int value) {
    return SpeechConfig_RecognizeType_IsValid(value);
  }
  static constexpr RecognizeType RecognizeType_MIN =
    SpeechConfig_RecognizeType_RecognizeType_MIN;
  static constexpr RecognizeType RecognizeType_MAX =
    SpeechConfig_RecognizeType_RecognizeType_MAX;
  static constexpr int RecognizeType_ARRAYSIZE =
    SpeechConfig_RecognizeType_RecognizeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecognizeType_descriptor() {
    return SpeechConfig_RecognizeType_descriptor();
  }
  template<typename T>
  static inline const std::string& RecognizeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecognizeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecognizeType_Name.");
    return SpeechConfig_RecognizeType_Name(enum_t_value);
  }
  static inline bool RecognizeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecognizeType* value) {
    return SpeechConfig_RecognizeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCustomWordFieldNumber = 3,
    kUseCustomWordsIdFieldNumber = 4,
    kKeyWordsFieldNumber = 9,
    kWordsReplaceFieldNumber = 8,
    kLangFieldNumber = 1,
    kSceneFieldNumber = 2,
    kRecognizeTypeFieldNumber = 5,
    kDisableConvertNumberFieldNumber = 6,
    kDisablePunctuationFieldNumber = 7,
  };
  // repeated string customWord = 3;
  int customword_size() const;
  private:
  int _internal_customword_size() const;
  public:
  void clear_customword();
  const std::string& customword(int index) const;
  std::string* mutable_customword(int index);
  void set_customword(int index, const std::string& value);
  void set_customword(int index, std::string&& value);
  void set_customword(int index, const char* value);
  void set_customword(int index, const char* value, size_t size);
  std::string* add_customword();
  void add_customword(const std::string& value);
  void add_customword(std::string&& value);
  void add_customword(const char* value);
  void add_customword(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& customword() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_customword();
  private:
  const std::string& _internal_customword(int index) const;
  std::string* _internal_add_customword();
  public:

  // repeated int32 useCustomWordsId = 4;
  int usecustomwordsid_size() const;
  private:
  int _internal_usecustomwordsid_size() const;
  public:
  void clear_usecustomwordsid();
  private:
  int32_t _internal_usecustomwordsid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_usecustomwordsid() const;
  void _internal_add_usecustomwordsid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_usecustomwordsid();
  public:
  int32_t usecustomwordsid(int index) const;
  void set_usecustomwordsid(int index, int32_t value);
  void add_usecustomwordsid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      usecustomwordsid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_usecustomwordsid();

  // repeated string keyWords = 9;
  int keywords_size() const;
  private:
  int _internal_keywords_size() const;
  public:
  void clear_keywords();
  const std::string& keywords(int index) const;
  std::string* mutable_keywords(int index);
  void set_keywords(int index, const std::string& value);
  void set_keywords(int index, std::string&& value);
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  std::string* add_keywords();
  void add_keywords(const std::string& value);
  void add_keywords(std::string&& value);
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keywords();
  private:
  const std::string& _internal_keywords(int index) const;
  std::string* _internal_add_keywords();
  public:

  // .WordsReplace wordsReplace = 8;
  bool has_wordsreplace() const;
  private:
  bool _internal_has_wordsreplace() const;
  public:
  void clear_wordsreplace();
  const ::WordsReplace& wordsreplace() const;
  PROTOBUF_NODISCARD ::WordsReplace* release_wordsreplace();
  ::WordsReplace* mutable_wordsreplace();
  void set_allocated_wordsreplace(::WordsReplace* wordsreplace);
  private:
  const ::WordsReplace& _internal_wordsreplace() const;
  ::WordsReplace* _internal_mutable_wordsreplace();
  public:
  void unsafe_arena_set_allocated_wordsreplace(
      ::WordsReplace* wordsreplace);
  ::WordsReplace* unsafe_arena_release_wordsreplace();

  // .SpeechConfig.Language lang = 1;
  void clear_lang();
  ::SpeechConfig_Language lang() const;
  void set_lang(::SpeechConfig_Language value);
  private:
  ::SpeechConfig_Language _internal_lang() const;
  void _internal_set_lang(::SpeechConfig_Language value);
  public:

  // .SpeechConfig.Scene scene = 2;
  void clear_scene();
  ::SpeechConfig_Scene scene() const;
  void set_scene(::SpeechConfig_Scene value);
  private:
  ::SpeechConfig_Scene _internal_scene() const;
  void _internal_set_scene(::SpeechConfig_Scene value);
  public:

  // .SpeechConfig.RecognizeType recognizeType = 5;
  void clear_recognizetype();
  ::SpeechConfig_RecognizeType recognizetype() const;
  void set_recognizetype(::SpeechConfig_RecognizeType value);
  private:
  ::SpeechConfig_RecognizeType _internal_recognizetype() const;
  void _internal_set_recognizetype(::SpeechConfig_RecognizeType value);
  public:

  // bool disableConvertNumber = 6;
  void clear_disableconvertnumber();
  bool disableconvertnumber() const;
  void set_disableconvertnumber(bool value);
  private:
  bool _internal_disableconvertnumber() const;
  void _internal_set_disableconvertnumber(bool value);
  public:

  // bool disablePunctuation = 7;
  void clear_disablepunctuation();
  bool disablepunctuation() const;
  void set_disablepunctuation(bool value);
  private:
  bool _internal_disablepunctuation() const;
  void _internal_set_disablepunctuation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SpeechConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> customword_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > usecustomwordsid_;
    mutable std::atomic<int> _usecustomwordsid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keywords_;
    ::WordsReplace* wordsreplace_;
    int lang_;
    int scene_;
    int recognizetype_;
    bool disableconvertnumber_;
    bool disablepunctuation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class WordsReplace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WordsReplace) */ {
 public:
  inline WordsReplace() : WordsReplace(nullptr) {}
  ~WordsReplace() override;
  explicit PROTOBUF_CONSTEXPR WordsReplace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WordsReplace(const WordsReplace& from);
  WordsReplace(WordsReplace&& from) noexcept
    : WordsReplace() {
    *this = ::std::move(from);
  }

  inline WordsReplace& operator=(const WordsReplace& from) {
    CopyFrom(from);
    return *this;
  }
  inline WordsReplace& operator=(WordsReplace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WordsReplace& default_instance() {
    return *internal_default_instance();
  }
  static inline const WordsReplace* internal_default_instance() {
    return reinterpret_cast<const WordsReplace*>(
               &_WordsReplace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WordsReplace& a, WordsReplace& b) {
    a.Swap(&b);
  }
  inline void Swap(WordsReplace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WordsReplace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WordsReplace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WordsReplace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WordsReplace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WordsReplace& from) {
    WordsReplace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WordsReplace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WordsReplace";
  }
  protected:
  explicit WordsReplace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeywordsFieldNumber = 1,
    kReplaceFieldNumber = 2,
  };
  // repeated string keywords = 1;
  int keywords_size() const;
  private:
  int _internal_keywords_size() const;
  public:
  void clear_keywords();
  const std::string& keywords(int index) const;
  std::string* mutable_keywords(int index);
  void set_keywords(int index, const std::string& value);
  void set_keywords(int index, std::string&& value);
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  std::string* add_keywords();
  void add_keywords(const std::string& value);
  void add_keywords(std::string&& value);
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keywords();
  private:
  const std::string& _internal_keywords(int index) const;
  std::string* _internal_add_keywords();
  public:

  // repeated string replace = 2;
  int replace_size() const;
  private:
  int _internal_replace_size() const;
  public:
  void clear_replace();
  const std::string& replace(int index) const;
  std::string* mutable_replace(int index);
  void set_replace(int index, const std::string& value);
  void set_replace(int index, std::string&& value);
  void set_replace(int index, const char* value);
  void set_replace(int index, const char* value, size_t size);
  std::string* add_replace();
  void add_replace(const std::string& value);
  void add_replace(std::string&& value);
  void add_replace(const char* value);
  void add_replace(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replace() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replace();
  private:
  const std::string& _internal_replace(int index) const;
  std::string* _internal_add_replace();
  public:

  // @@protoc_insertion_point(class_scope:WordsReplace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keywords_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingSpeechConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingSpeechConfig) */ {
 public:
  inline StreamingSpeechConfig() : StreamingSpeechConfig(nullptr) {}
  ~StreamingSpeechConfig() override;
  explicit PROTOBUF_CONSTEXPR StreamingSpeechConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingSpeechConfig(const StreamingSpeechConfig& from);
  StreamingSpeechConfig(StreamingSpeechConfig&& from) noexcept
    : StreamingSpeechConfig() {
    *this = ::std::move(from);
  }

  inline StreamingSpeechConfig& operator=(const StreamingSpeechConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingSpeechConfig& operator=(StreamingSpeechConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingSpeechConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingSpeechConfig* internal_default_instance() {
    return reinterpret_cast<const StreamingSpeechConfig*>(
               &_StreamingSpeechConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StreamingSpeechConfig& a, StreamingSpeechConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingSpeechConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingSpeechConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingSpeechConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingSpeechConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingSpeechConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingSpeechConfig& from) {
    StreamingSpeechConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingSpeechConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingSpeechConfig";
  }
  protected:
  explicit StreamingSpeechConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 1,
    kSpeechConfigFieldNumber = 2,
  };
  // .AudioConfig audioConfig = 1;
  bool has_audioconfig() const;
  private:
  bool _internal_has_audioconfig() const;
  public:
  void clear_audioconfig();
  const ::AudioConfig& audioconfig() const;
  PROTOBUF_NODISCARD ::AudioConfig* release_audioconfig();
  ::AudioConfig* mutable_audioconfig();
  void set_allocated_audioconfig(::AudioConfig* audioconfig);
  private:
  const ::AudioConfig& _internal_audioconfig() const;
  ::AudioConfig* _internal_mutable_audioconfig();
  public:
  void unsafe_arena_set_allocated_audioconfig(
      ::AudioConfig* audioconfig);
  ::AudioConfig* unsafe_arena_release_audioconfig();

  // .SpeechConfig speechConfig = 2;
  bool has_speechconfig() const;
  private:
  bool _internal_has_speechconfig() const;
  public:
  void clear_speechconfig();
  const ::SpeechConfig& speechconfig() const;
  PROTOBUF_NODISCARD ::SpeechConfig* release_speechconfig();
  ::SpeechConfig* mutable_speechconfig();
  void set_allocated_speechconfig(::SpeechConfig* speechconfig);
  private:
  const ::SpeechConfig& _internal_speechconfig() const;
  ::SpeechConfig* _internal_mutable_speechconfig();
  public:
  void unsafe_arena_set_allocated_speechconfig(
      ::SpeechConfig* speechconfig);
  ::SpeechConfig* unsafe_arena_release_speechconfig();

  // @@protoc_insertion_point(class_scope:StreamingSpeechConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::AudioConfig* audioconfig_;
    ::SpeechConfig* speechconfig_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingSpeechRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingSpeechRequest) */ {
 public:
  inline StreamingSpeechRequest() : StreamingSpeechRequest(nullptr) {}
  ~StreamingSpeechRequest() override;
  explicit PROTOBUF_CONSTEXPR StreamingSpeechRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingSpeechRequest(const StreamingSpeechRequest& from);
  StreamingSpeechRequest(StreamingSpeechRequest&& from) noexcept
    : StreamingSpeechRequest() {
    *this = ::std::move(from);
  }

  inline StreamingSpeechRequest& operator=(const StreamingSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingSpeechRequest& operator=(StreamingSpeechRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingSpeechRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestPayloadCase {
    kStreamingSpeechConfig = 1,
    kAudioData = 2,
    REQUESTPAYLOAD_NOT_SET = 0,
  };

  static inline const StreamingSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const StreamingSpeechRequest*>(
               &_StreamingSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamingSpeechRequest& a, StreamingSpeechRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingSpeechRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingSpeechRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingSpeechRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingSpeechRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingSpeechRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingSpeechRequest& from) {
    StreamingSpeechRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingSpeechRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingSpeechRequest";
  }
  protected:
  explicit StreamingSpeechRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamingSpeechConfigFieldNumber = 1,
    kAudioDataFieldNumber = 2,
  };
  // .StreamingSpeechConfig streamingSpeechConfig = 1;
  bool has_streamingspeechconfig() const;
  private:
  bool _internal_has_streamingspeechconfig() const;
  public:
  void clear_streamingspeechconfig();
  const ::StreamingSpeechConfig& streamingspeechconfig() const;
  PROTOBUF_NODISCARD ::StreamingSpeechConfig* release_streamingspeechconfig();
  ::StreamingSpeechConfig* mutable_streamingspeechconfig();
  void set_allocated_streamingspeechconfig(::StreamingSpeechConfig* streamingspeechconfig);
  private:
  const ::StreamingSpeechConfig& _internal_streamingspeechconfig() const;
  ::StreamingSpeechConfig* _internal_mutable_streamingspeechconfig();
  public:
  void unsafe_arena_set_allocated_streamingspeechconfig(
      ::StreamingSpeechConfig* streamingspeechconfig);
  ::StreamingSpeechConfig* unsafe_arena_release_streamingspeechconfig();

  // bytes audioData = 2;
  bool has_audiodata() const;
  private:
  bool _internal_has_audiodata() const;
  public:
  void clear_audiodata();
  const std::string& audiodata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiodata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiodata();
  PROTOBUF_NODISCARD std::string* release_audiodata();
  void set_allocated_audiodata(std::string* audiodata);
  private:
  const std::string& _internal_audiodata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiodata(const std::string& value);
  std::string* _internal_mutable_audiodata();
  public:

  void clear_requestPayload();
  RequestPayloadCase requestPayload_case() const;
  // @@protoc_insertion_point(class_scope:StreamingSpeechRequest)
 private:
  class _Internal;
  void set_has_streamingspeechconfig();
  void set_has_audiodata();

  inline bool has_requestPayload() const;
  inline void clear_has_requestPayload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestPayloadUnion {
      constexpr RequestPayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::StreamingSpeechConfig* streamingspeechconfig_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiodata_;
    } requestPayload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingSpeechResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingSpeechResponse) */ {
 public:
  inline StreamingSpeechResponse() : StreamingSpeechResponse(nullptr) {}
  ~StreamingSpeechResponse() override;
  explicit PROTOBUF_CONSTEXPR StreamingSpeechResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingSpeechResponse(const StreamingSpeechResponse& from);
  StreamingSpeechResponse(StreamingSpeechResponse&& from) noexcept
    : StreamingSpeechResponse() {
    *this = ::std::move(from);
  }

  inline StreamingSpeechResponse& operator=(const StreamingSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingSpeechResponse& operator=(StreamingSpeechResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingSpeechResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const StreamingSpeechResponse*>(
               &_StreamingSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamingSpeechResponse& a, StreamingSpeechResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingSpeechResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingSpeechResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingSpeechResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingSpeechResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingSpeechResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingSpeechResponse& from) {
    StreamingSpeechResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingSpeechResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingSpeechResponse";
  }
  protected:
  explicit StreamingSpeechResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalStreamIdFieldNumber = 1,
    kResultFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string globalStreamId = 1;
  void clear_globalstreamid();
  const std::string& globalstreamid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_globalstreamid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_globalstreamid();
  PROTOBUF_NODISCARD std::string* release_globalstreamid();
  void set_allocated_globalstreamid(std::string* globalstreamid);
  private:
  const std::string& _internal_globalstreamid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_globalstreamid(const std::string& value);
  std::string* _internal_mutable_globalstreamid();
  public:

  // .StreamingSpeechResult result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::StreamingSpeechResult& result() const;
  PROTOBUF_NODISCARD ::StreamingSpeechResult* release_result();
  ::StreamingSpeechResult* mutable_result();
  void set_allocated_result(::StreamingSpeechResult* result);
  private:
  const ::StreamingSpeechResult& _internal_result() const;
  ::StreamingSpeechResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::StreamingSpeechResult* result);
  ::StreamingSpeechResult* unsafe_arena_release_result();

  // .StreamingSpeechStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::StreamingSpeechStatus& status() const;
  PROTOBUF_NODISCARD ::StreamingSpeechStatus* release_status();
  ::StreamingSpeechStatus* mutable_status();
  void set_allocated_status(::StreamingSpeechStatus* status);
  private:
  const ::StreamingSpeechStatus& _internal_status() const;
  ::StreamingSpeechStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::StreamingSpeechStatus* status);
  ::StreamingSpeechStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:StreamingSpeechResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr globalstreamid_;
    ::StreamingSpeechResult* result_;
    ::StreamingSpeechStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingSpeechResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingSpeechResult) */ {
 public:
  inline StreamingSpeechResult() : StreamingSpeechResult(nullptr) {}
  ~StreamingSpeechResult() override;
  explicit PROTOBUF_CONSTEXPR StreamingSpeechResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingSpeechResult(const StreamingSpeechResult& from);
  StreamingSpeechResult(StreamingSpeechResult&& from) noexcept
    : StreamingSpeechResult() {
    *this = ::std::move(from);
  }

  inline StreamingSpeechResult& operator=(const StreamingSpeechResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingSpeechResult& operator=(StreamingSpeechResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingSpeechResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingSpeechResult* internal_default_instance() {
    return reinterpret_cast<const StreamingSpeechResult*>(
               &_StreamingSpeechResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamingSpeechResult& a, StreamingSpeechResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingSpeechResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingSpeechResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingSpeechResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingSpeechResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingSpeechResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingSpeechResult& from) {
    StreamingSpeechResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingSpeechResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingSpeechResult";
  }
  protected:
  explicit StreamingSpeechResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBestTranscriptionFieldNumber = 2,
    kIsFinalFieldNumber = 1,
  };
  // .StreamingTranscription bestTranscription = 2;
  bool has_besttranscription() const;
  private:
  bool _internal_has_besttranscription() const;
  public:
  void clear_besttranscription();
  const ::StreamingTranscription& besttranscription() const;
  PROTOBUF_NODISCARD ::StreamingTranscription* release_besttranscription();
  ::StreamingTranscription* mutable_besttranscription();
  void set_allocated_besttranscription(::StreamingTranscription* besttranscription);
  private:
  const ::StreamingTranscription& _internal_besttranscription() const;
  ::StreamingTranscription* _internal_mutable_besttranscription();
  public:
  void unsafe_arena_set_allocated_besttranscription(
      ::StreamingTranscription* besttranscription);
  ::StreamingTranscription* unsafe_arena_release_besttranscription();

  // bool isFinal = 1;
  void clear_isfinal();
  bool isfinal() const;
  void set_isfinal(bool value);
  private:
  bool _internal_isfinal() const;
  void _internal_set_isfinal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StreamingSpeechResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::StreamingTranscription* besttranscription_;
    bool isfinal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingSpeechStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingSpeechStatus) */ {
 public:
  inline StreamingSpeechStatus() : StreamingSpeechStatus(nullptr) {}
  ~StreamingSpeechStatus() override;
  explicit PROTOBUF_CONSTEXPR StreamingSpeechStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingSpeechStatus(const StreamingSpeechStatus& from);
  StreamingSpeechStatus(StreamingSpeechStatus&& from) noexcept
    : StreamingSpeechStatus() {
    *this = ::std::move(from);
  }

  inline StreamingSpeechStatus& operator=(const StreamingSpeechStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingSpeechStatus& operator=(StreamingSpeechStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingSpeechStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingSpeechStatus* internal_default_instance() {
    return reinterpret_cast<const StreamingSpeechStatus*>(
               &_StreamingSpeechStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamingSpeechStatus& a, StreamingSpeechStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingSpeechStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingSpeechStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingSpeechStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingSpeechStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingSpeechStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingSpeechStatus& from) {
    StreamingSpeechStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingSpeechStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingSpeechStatus";
  }
  protected:
  explicit StreamingSpeechStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessedTimestampFieldNumber = 1,
  };
  // int64 processedTimestamp = 1;
  void clear_processedtimestamp();
  int64_t processedtimestamp() const;
  void set_processedtimestamp(int64_t value);
  private:
  int64_t _internal_processedtimestamp() const;
  void _internal_set_processedtimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StreamingSpeechStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t processedtimestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingTranscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingTranscription) */ {
 public:
  inline StreamingTranscription() : StreamingTranscription(nullptr) {}
  ~StreamingTranscription() override;
  explicit PROTOBUF_CONSTEXPR StreamingTranscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingTranscription(const StreamingTranscription& from);
  StreamingTranscription(StreamingTranscription&& from) noexcept
    : StreamingTranscription() {
    *this = ::std::move(from);
  }

  inline StreamingTranscription& operator=(const StreamingTranscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingTranscription& operator=(StreamingTranscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingTranscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingTranscription* internal_default_instance() {
    return reinterpret_cast<const StreamingTranscription*>(
               &_StreamingTranscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamingTranscription& a, StreamingTranscription& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingTranscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingTranscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingTranscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingTranscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingTranscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingTranscription& from) {
    StreamingTranscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingTranscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingTranscription";
  }
  protected:
  explicit StreamingTranscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyWordsTypeFieldNumber = 2,
    kPieceFieldNumber = 3,
    kTranscribedTextFieldNumber = 1,
  };
  // repeated .KeyWordsType keyWordsType = 2;
  int keywordstype_size() const;
  private:
  int _internal_keywordstype_size() const;
  public:
  void clear_keywordstype();
  ::KeyWordsType* mutable_keywordstype(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KeyWordsType >*
      mutable_keywordstype();
  private:
  const ::KeyWordsType& _internal_keywordstype(int index) const;
  ::KeyWordsType* _internal_add_keywordstype();
  public:
  const ::KeyWordsType& keywordstype(int index) const;
  ::KeyWordsType* add_keywordstype();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KeyWordsType >&
      keywordstype() const;

  // repeated .StreamingTranscriptionPiece piece = 3;
  int piece_size() const;
  private:
  int _internal_piece_size() const;
  public:
  void clear_piece();
  ::StreamingTranscriptionPiece* mutable_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StreamingTranscriptionPiece >*
      mutable_piece();
  private:
  const ::StreamingTranscriptionPiece& _internal_piece(int index) const;
  ::StreamingTranscriptionPiece* _internal_add_piece();
  public:
  const ::StreamingTranscriptionPiece& piece(int index) const;
  ::StreamingTranscriptionPiece* add_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StreamingTranscriptionPiece >&
      piece() const;

  // string transcribedText = 1;
  void clear_transcribedtext();
  const std::string& transcribedtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcribedtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcribedtext();
  PROTOBUF_NODISCARD std::string* release_transcribedtext();
  void set_allocated_transcribedtext(std::string* transcribedtext);
  private:
  const std::string& _internal_transcribedtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcribedtext(const std::string& value);
  std::string* _internal_mutable_transcribedtext();
  public:

  // @@protoc_insertion_point(class_scope:StreamingTranscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KeyWordsType > keywordstype_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StreamingTranscriptionPiece > piece_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcribedtext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class KeyWordsType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeyWordsType) */ {
 public:
  inline KeyWordsType() : KeyWordsType(nullptr) {}
  ~KeyWordsType() override;
  explicit PROTOBUF_CONSTEXPR KeyWordsType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyWordsType(const KeyWordsType& from);
  KeyWordsType(KeyWordsType&& from) noexcept
    : KeyWordsType() {
    *this = ::std::move(from);
  }

  inline KeyWordsType& operator=(const KeyWordsType& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyWordsType& operator=(KeyWordsType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyWordsType& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyWordsType* internal_default_instance() {
    return reinterpret_cast<const KeyWordsType*>(
               &_KeyWordsType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KeyWordsType& a, KeyWordsType& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyWordsType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyWordsType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyWordsType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyWordsType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyWordsType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyWordsType& from) {
    KeyWordsType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyWordsType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeyWordsType";
  }
  protected:
  explicit KeyWordsType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyWordsFieldNumber = 1,
    kKeyWordsScoreFieldNumber = 2,
    kStartTimestampFieldNumber = 3,
    kEndTimestampFieldNumber = 4,
  };
  // string keyWords = 1;
  void clear_keywords();
  const std::string& keywords() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keywords(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keywords();
  PROTOBUF_NODISCARD std::string* release_keywords();
  void set_allocated_keywords(std::string* keywords);
  private:
  const std::string& _internal_keywords() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keywords(const std::string& value);
  std::string* _internal_mutable_keywords();
  public:

  // float keyWordsScore = 2;
  void clear_keywordsscore();
  float keywordsscore() const;
  void set_keywordsscore(float value);
  private:
  float _internal_keywordsscore() const;
  void _internal_set_keywordsscore(float value);
  public:

  // int32 startTimestamp = 3;
  void clear_starttimestamp();
  int32_t starttimestamp() const;
  void set_starttimestamp(int32_t value);
  private:
  int32_t _internal_starttimestamp() const;
  void _internal_set_starttimestamp(int32_t value);
  public:

  // int32 endTimestamp = 4;
  void clear_endtimestamp();
  int32_t endtimestamp() const;
  void set_endtimestamp(int32_t value);
  private:
  int32_t _internal_endtimestamp() const;
  void _internal_set_endtimestamp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KeyWordsType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keywords_;
    float keywordsscore_;
    int32_t starttimestamp_;
    int32_t endtimestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// -------------------------------------------------------------------

class StreamingTranscriptionPiece final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamingTranscriptionPiece) */ {
 public:
  inline StreamingTranscriptionPiece() : StreamingTranscriptionPiece(nullptr) {}
  ~StreamingTranscriptionPiece() override;
  explicit PROTOBUF_CONSTEXPR StreamingTranscriptionPiece(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingTranscriptionPiece(const StreamingTranscriptionPiece& from);
  StreamingTranscriptionPiece(StreamingTranscriptionPiece&& from) noexcept
    : StreamingTranscriptionPiece() {
    *this = ::std::move(from);
  }

  inline StreamingTranscriptionPiece& operator=(const StreamingTranscriptionPiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingTranscriptionPiece& operator=(StreamingTranscriptionPiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingTranscriptionPiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingTranscriptionPiece* internal_default_instance() {
    return reinterpret_cast<const StreamingTranscriptionPiece*>(
               &_StreamingTranscriptionPiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StreamingTranscriptionPiece& a, StreamingTranscriptionPiece& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingTranscriptionPiece* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingTranscriptionPiece* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingTranscriptionPiece* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingTranscriptionPiece>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingTranscriptionPiece& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingTranscriptionPiece& from) {
    StreamingTranscriptionPiece::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingTranscriptionPiece* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamingTranscriptionPiece";
  }
  protected:
  explicit StreamingTranscriptionPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranscribedTextFieldNumber = 1,
    kBeginTimestampFieldNumber = 2,
    kEndTimestampFieldNumber = 3,
    kTranscribedTypeFieldNumber = 4,
  };
  // string transcribedText = 1;
  void clear_transcribedtext();
  const std::string& transcribedtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcribedtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcribedtext();
  PROTOBUF_NODISCARD std::string* release_transcribedtext();
  void set_allocated_transcribedtext(std::string* transcribedtext);
  private:
  const std::string& _internal_transcribedtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcribedtext(const std::string& value);
  std::string* _internal_mutable_transcribedtext();
  public:

  // int64 beginTimestamp = 2;
  void clear_begintimestamp();
  int64_t begintimestamp() const;
  void set_begintimestamp(int64_t value);
  private:
  int64_t _internal_begintimestamp() const;
  void _internal_set_begintimestamp(int64_t value);
  public:

  // int64 endTimestamp = 3;
  void clear_endtimestamp();
  int64_t endtimestamp() const;
  void set_endtimestamp(int64_t value);
  private:
  int64_t _internal_endtimestamp() const;
  void _internal_set_endtimestamp(int64_t value);
  public:

  // int32 transcribedType = 4;
  void clear_transcribedtype();
  int32_t transcribedtype() const;
  void set_transcribedtype(int32_t value);
  private:
  int32_t _internal_transcribedtype() const;
  void _internal_set_transcribedtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StreamingTranscriptionPiece)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcribedtext_;
    int64_t begintimestamp_;
    int64_t endtimestamp_;
    int32_t transcribedtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_yitu_5fstreaming_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioConfig

// .AudioConfig.AudioEncoding aue = 1;
inline void AudioConfig::clear_aue() {
  _impl_.aue_ = 0;
}
inline ::AudioConfig_AudioEncoding AudioConfig::_internal_aue() const {
  return static_cast< ::AudioConfig_AudioEncoding >(_impl_.aue_);
}
inline ::AudioConfig_AudioEncoding AudioConfig::aue() const {
  // @@protoc_insertion_point(field_get:AudioConfig.aue)
  return _internal_aue();
}
inline void AudioConfig::_internal_set_aue(::AudioConfig_AudioEncoding value) {
  
  _impl_.aue_ = value;
}
inline void AudioConfig::set_aue(::AudioConfig_AudioEncoding value) {
  _internal_set_aue(value);
  // @@protoc_insertion_point(field_set:AudioConfig.aue)
}

// int32 sampleRate = 8000;
inline void AudioConfig::clear_samplerate() {
  _impl_.samplerate_ = 0;
}
inline int32_t AudioConfig::_internal_samplerate() const {
  return _impl_.samplerate_;
}
inline int32_t AudioConfig::samplerate() const {
  // @@protoc_insertion_point(field_get:AudioConfig.sampleRate)
  return _internal_samplerate();
}
inline void AudioConfig::_internal_set_samplerate(int32_t value) {
  
  _impl_.samplerate_ = value;
}
inline void AudioConfig::set_samplerate(int32_t value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:AudioConfig.sampleRate)
}

// -------------------------------------------------------------------

// SpeechConfig

// .SpeechConfig.Language lang = 1;
inline void SpeechConfig::clear_lang() {
  _impl_.lang_ = 0;
}
inline ::SpeechConfig_Language SpeechConfig::_internal_lang() const {
  return static_cast< ::SpeechConfig_Language >(_impl_.lang_);
}
inline ::SpeechConfig_Language SpeechConfig::lang() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.lang)
  return _internal_lang();
}
inline void SpeechConfig::_internal_set_lang(::SpeechConfig_Language value) {
  
  _impl_.lang_ = value;
}
inline void SpeechConfig::set_lang(::SpeechConfig_Language value) {
  _internal_set_lang(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.lang)
}

// .SpeechConfig.Scene scene = 2;
inline void SpeechConfig::clear_scene() {
  _impl_.scene_ = 0;
}
inline ::SpeechConfig_Scene SpeechConfig::_internal_scene() const {
  return static_cast< ::SpeechConfig_Scene >(_impl_.scene_);
}
inline ::SpeechConfig_Scene SpeechConfig::scene() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.scene)
  return _internal_scene();
}
inline void SpeechConfig::_internal_set_scene(::SpeechConfig_Scene value) {
  
  _impl_.scene_ = value;
}
inline void SpeechConfig::set_scene(::SpeechConfig_Scene value) {
  _internal_set_scene(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.scene)
}

// repeated string customWord = 3;
inline int SpeechConfig::_internal_customword_size() const {
  return _impl_.customword_.size();
}
inline int SpeechConfig::customword_size() const {
  return _internal_customword_size();
}
inline void SpeechConfig::clear_customword() {
  _impl_.customword_.Clear();
}
inline std::string* SpeechConfig::add_customword() {
  std::string* _s = _internal_add_customword();
  // @@protoc_insertion_point(field_add_mutable:SpeechConfig.customWord)
  return _s;
}
inline const std::string& SpeechConfig::_internal_customword(int index) const {
  return _impl_.customword_.Get(index);
}
inline const std::string& SpeechConfig::customword(int index) const {
  // @@protoc_insertion_point(field_get:SpeechConfig.customWord)
  return _internal_customword(index);
}
inline std::string* SpeechConfig::mutable_customword(int index) {
  // @@protoc_insertion_point(field_mutable:SpeechConfig.customWord)
  return _impl_.customword_.Mutable(index);
}
inline void SpeechConfig::set_customword(int index, const std::string& value) {
  _impl_.customword_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.customWord)
}
inline void SpeechConfig::set_customword(int index, std::string&& value) {
  _impl_.customword_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SpeechConfig.customWord)
}
inline void SpeechConfig::set_customword(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.customword_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpeechConfig.customWord)
}
inline void SpeechConfig::set_customword(int index, const char* value, size_t size) {
  _impl_.customword_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpeechConfig.customWord)
}
inline std::string* SpeechConfig::_internal_add_customword() {
  return _impl_.customword_.Add();
}
inline void SpeechConfig::add_customword(const std::string& value) {
  _impl_.customword_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpeechConfig.customWord)
}
inline void SpeechConfig::add_customword(std::string&& value) {
  _impl_.customword_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpeechConfig.customWord)
}
inline void SpeechConfig::add_customword(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.customword_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpeechConfig.customWord)
}
inline void SpeechConfig::add_customword(const char* value, size_t size) {
  _impl_.customword_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpeechConfig.customWord)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpeechConfig::customword() const {
  // @@protoc_insertion_point(field_list:SpeechConfig.customWord)
  return _impl_.customword_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpeechConfig::mutable_customword() {
  // @@protoc_insertion_point(field_mutable_list:SpeechConfig.customWord)
  return &_impl_.customword_;
}

// repeated int32 useCustomWordsId = 4;
inline int SpeechConfig::_internal_usecustomwordsid_size() const {
  return _impl_.usecustomwordsid_.size();
}
inline int SpeechConfig::usecustomwordsid_size() const {
  return _internal_usecustomwordsid_size();
}
inline void SpeechConfig::clear_usecustomwordsid() {
  _impl_.usecustomwordsid_.Clear();
}
inline int32_t SpeechConfig::_internal_usecustomwordsid(int index) const {
  return _impl_.usecustomwordsid_.Get(index);
}
inline int32_t SpeechConfig::usecustomwordsid(int index) const {
  // @@protoc_insertion_point(field_get:SpeechConfig.useCustomWordsId)
  return _internal_usecustomwordsid(index);
}
inline void SpeechConfig::set_usecustomwordsid(int index, int32_t value) {
  _impl_.usecustomwordsid_.Set(index, value);
  // @@protoc_insertion_point(field_set:SpeechConfig.useCustomWordsId)
}
inline void SpeechConfig::_internal_add_usecustomwordsid(int32_t value) {
  _impl_.usecustomwordsid_.Add(value);
}
inline void SpeechConfig::add_usecustomwordsid(int32_t value) {
  _internal_add_usecustomwordsid(value);
  // @@protoc_insertion_point(field_add:SpeechConfig.useCustomWordsId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SpeechConfig::_internal_usecustomwordsid() const {
  return _impl_.usecustomwordsid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SpeechConfig::usecustomwordsid() const {
  // @@protoc_insertion_point(field_list:SpeechConfig.useCustomWordsId)
  return _internal_usecustomwordsid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SpeechConfig::_internal_mutable_usecustomwordsid() {
  return &_impl_.usecustomwordsid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SpeechConfig::mutable_usecustomwordsid() {
  // @@protoc_insertion_point(field_mutable_list:SpeechConfig.useCustomWordsId)
  return _internal_mutable_usecustomwordsid();
}

// .SpeechConfig.RecognizeType recognizeType = 5;
inline void SpeechConfig::clear_recognizetype() {
  _impl_.recognizetype_ = 0;
}
inline ::SpeechConfig_RecognizeType SpeechConfig::_internal_recognizetype() const {
  return static_cast< ::SpeechConfig_RecognizeType >(_impl_.recognizetype_);
}
inline ::SpeechConfig_RecognizeType SpeechConfig::recognizetype() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.recognizeType)
  return _internal_recognizetype();
}
inline void SpeechConfig::_internal_set_recognizetype(::SpeechConfig_RecognizeType value) {
  
  _impl_.recognizetype_ = value;
}
inline void SpeechConfig::set_recognizetype(::SpeechConfig_RecognizeType value) {
  _internal_set_recognizetype(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.recognizeType)
}

// bool disableConvertNumber = 6;
inline void SpeechConfig::clear_disableconvertnumber() {
  _impl_.disableconvertnumber_ = false;
}
inline bool SpeechConfig::_internal_disableconvertnumber() const {
  return _impl_.disableconvertnumber_;
}
inline bool SpeechConfig::disableconvertnumber() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.disableConvertNumber)
  return _internal_disableconvertnumber();
}
inline void SpeechConfig::_internal_set_disableconvertnumber(bool value) {
  
  _impl_.disableconvertnumber_ = value;
}
inline void SpeechConfig::set_disableconvertnumber(bool value) {
  _internal_set_disableconvertnumber(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.disableConvertNumber)
}

// bool disablePunctuation = 7;
inline void SpeechConfig::clear_disablepunctuation() {
  _impl_.disablepunctuation_ = false;
}
inline bool SpeechConfig::_internal_disablepunctuation() const {
  return _impl_.disablepunctuation_;
}
inline bool SpeechConfig::disablepunctuation() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.disablePunctuation)
  return _internal_disablepunctuation();
}
inline void SpeechConfig::_internal_set_disablepunctuation(bool value) {
  
  _impl_.disablepunctuation_ = value;
}
inline void SpeechConfig::set_disablepunctuation(bool value) {
  _internal_set_disablepunctuation(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.disablePunctuation)
}

// .WordsReplace wordsReplace = 8;
inline bool SpeechConfig::_internal_has_wordsreplace() const {
  return this != internal_default_instance() && _impl_.wordsreplace_ != nullptr;
}
inline bool SpeechConfig::has_wordsreplace() const {
  return _internal_has_wordsreplace();
}
inline void SpeechConfig::clear_wordsreplace() {
  if (GetArenaForAllocation() == nullptr && _impl_.wordsreplace_ != nullptr) {
    delete _impl_.wordsreplace_;
  }
  _impl_.wordsreplace_ = nullptr;
}
inline const ::WordsReplace& SpeechConfig::_internal_wordsreplace() const {
  const ::WordsReplace* p = _impl_.wordsreplace_;
  return p != nullptr ? *p : reinterpret_cast<const ::WordsReplace&>(
      ::_WordsReplace_default_instance_);
}
inline const ::WordsReplace& SpeechConfig::wordsreplace() const {
  // @@protoc_insertion_point(field_get:SpeechConfig.wordsReplace)
  return _internal_wordsreplace();
}
inline void SpeechConfig::unsafe_arena_set_allocated_wordsreplace(
    ::WordsReplace* wordsreplace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wordsreplace_);
  }
  _impl_.wordsreplace_ = wordsreplace;
  if (wordsreplace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SpeechConfig.wordsReplace)
}
inline ::WordsReplace* SpeechConfig::release_wordsreplace() {
  
  ::WordsReplace* temp = _impl_.wordsreplace_;
  _impl_.wordsreplace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WordsReplace* SpeechConfig::unsafe_arena_release_wordsreplace() {
  // @@protoc_insertion_point(field_release:SpeechConfig.wordsReplace)
  
  ::WordsReplace* temp = _impl_.wordsreplace_;
  _impl_.wordsreplace_ = nullptr;
  return temp;
}
inline ::WordsReplace* SpeechConfig::_internal_mutable_wordsreplace() {
  
  if (_impl_.wordsreplace_ == nullptr) {
    auto* p = CreateMaybeMessage<::WordsReplace>(GetArenaForAllocation());
    _impl_.wordsreplace_ = p;
  }
  return _impl_.wordsreplace_;
}
inline ::WordsReplace* SpeechConfig::mutable_wordsreplace() {
  ::WordsReplace* _msg = _internal_mutable_wordsreplace();
  // @@protoc_insertion_point(field_mutable:SpeechConfig.wordsReplace)
  return _msg;
}
inline void SpeechConfig::set_allocated_wordsreplace(::WordsReplace* wordsreplace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wordsreplace_;
  }
  if (wordsreplace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wordsreplace);
    if (message_arena != submessage_arena) {
      wordsreplace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wordsreplace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wordsreplace_ = wordsreplace;
  // @@protoc_insertion_point(field_set_allocated:SpeechConfig.wordsReplace)
}

// repeated string keyWords = 9;
inline int SpeechConfig::_internal_keywords_size() const {
  return _impl_.keywords_.size();
}
inline int SpeechConfig::keywords_size() const {
  return _internal_keywords_size();
}
inline void SpeechConfig::clear_keywords() {
  _impl_.keywords_.Clear();
}
inline std::string* SpeechConfig::add_keywords() {
  std::string* _s = _internal_add_keywords();
  // @@protoc_insertion_point(field_add_mutable:SpeechConfig.keyWords)
  return _s;
}
inline const std::string& SpeechConfig::_internal_keywords(int index) const {
  return _impl_.keywords_.Get(index);
}
inline const std::string& SpeechConfig::keywords(int index) const {
  // @@protoc_insertion_point(field_get:SpeechConfig.keyWords)
  return _internal_keywords(index);
}
inline std::string* SpeechConfig::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:SpeechConfig.keyWords)
  return _impl_.keywords_.Mutable(index);
}
inline void SpeechConfig::set_keywords(int index, const std::string& value) {
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SpeechConfig.keyWords)
}
inline void SpeechConfig::set_keywords(int index, std::string&& value) {
  _impl_.keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SpeechConfig.keyWords)
}
inline void SpeechConfig::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpeechConfig.keyWords)
}
inline void SpeechConfig::set_keywords(int index, const char* value, size_t size) {
  _impl_.keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpeechConfig.keyWords)
}
inline std::string* SpeechConfig::_internal_add_keywords() {
  return _impl_.keywords_.Add();
}
inline void SpeechConfig::add_keywords(const std::string& value) {
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpeechConfig.keyWords)
}
inline void SpeechConfig::add_keywords(std::string&& value) {
  _impl_.keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpeechConfig.keyWords)
}
inline void SpeechConfig::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpeechConfig.keyWords)
}
inline void SpeechConfig::add_keywords(const char* value, size_t size) {
  _impl_.keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpeechConfig.keyWords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpeechConfig::keywords() const {
  // @@protoc_insertion_point(field_list:SpeechConfig.keyWords)
  return _impl_.keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpeechConfig::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:SpeechConfig.keyWords)
  return &_impl_.keywords_;
}

// -------------------------------------------------------------------

// WordsReplace

// repeated string keywords = 1;
inline int WordsReplace::_internal_keywords_size() const {
  return _impl_.keywords_.size();
}
inline int WordsReplace::keywords_size() const {
  return _internal_keywords_size();
}
inline void WordsReplace::clear_keywords() {
  _impl_.keywords_.Clear();
}
inline std::string* WordsReplace::add_keywords() {
  std::string* _s = _internal_add_keywords();
  // @@protoc_insertion_point(field_add_mutable:WordsReplace.keywords)
  return _s;
}
inline const std::string& WordsReplace::_internal_keywords(int index) const {
  return _impl_.keywords_.Get(index);
}
inline const std::string& WordsReplace::keywords(int index) const {
  // @@protoc_insertion_point(field_get:WordsReplace.keywords)
  return _internal_keywords(index);
}
inline std::string* WordsReplace::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:WordsReplace.keywords)
  return _impl_.keywords_.Mutable(index);
}
inline void WordsReplace::set_keywords(int index, const std::string& value) {
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:WordsReplace.keywords)
}
inline void WordsReplace::set_keywords(int index, std::string&& value) {
  _impl_.keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:WordsReplace.keywords)
}
inline void WordsReplace::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:WordsReplace.keywords)
}
inline void WordsReplace::set_keywords(int index, const char* value, size_t size) {
  _impl_.keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WordsReplace.keywords)
}
inline std::string* WordsReplace::_internal_add_keywords() {
  return _impl_.keywords_.Add();
}
inline void WordsReplace::add_keywords(const std::string& value) {
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:WordsReplace.keywords)
}
inline void WordsReplace::add_keywords(std::string&& value) {
  _impl_.keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:WordsReplace.keywords)
}
inline void WordsReplace::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:WordsReplace.keywords)
}
inline void WordsReplace::add_keywords(const char* value, size_t size) {
  _impl_.keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:WordsReplace.keywords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WordsReplace::keywords() const {
  // @@protoc_insertion_point(field_list:WordsReplace.keywords)
  return _impl_.keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WordsReplace::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:WordsReplace.keywords)
  return &_impl_.keywords_;
}

// repeated string replace = 2;
inline int WordsReplace::_internal_replace_size() const {
  return _impl_.replace_.size();
}
inline int WordsReplace::replace_size() const {
  return _internal_replace_size();
}
inline void WordsReplace::clear_replace() {
  _impl_.replace_.Clear();
}
inline std::string* WordsReplace::add_replace() {
  std::string* _s = _internal_add_replace();
  // @@protoc_insertion_point(field_add_mutable:WordsReplace.replace)
  return _s;
}
inline const std::string& WordsReplace::_internal_replace(int index) const {
  return _impl_.replace_.Get(index);
}
inline const std::string& WordsReplace::replace(int index) const {
  // @@protoc_insertion_point(field_get:WordsReplace.replace)
  return _internal_replace(index);
}
inline std::string* WordsReplace::mutable_replace(int index) {
  // @@protoc_insertion_point(field_mutable:WordsReplace.replace)
  return _impl_.replace_.Mutable(index);
}
inline void WordsReplace::set_replace(int index, const std::string& value) {
  _impl_.replace_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:WordsReplace.replace)
}
inline void WordsReplace::set_replace(int index, std::string&& value) {
  _impl_.replace_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:WordsReplace.replace)
}
inline void WordsReplace::set_replace(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replace_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:WordsReplace.replace)
}
inline void WordsReplace::set_replace(int index, const char* value, size_t size) {
  _impl_.replace_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WordsReplace.replace)
}
inline std::string* WordsReplace::_internal_add_replace() {
  return _impl_.replace_.Add();
}
inline void WordsReplace::add_replace(const std::string& value) {
  _impl_.replace_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:WordsReplace.replace)
}
inline void WordsReplace::add_replace(std::string&& value) {
  _impl_.replace_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:WordsReplace.replace)
}
inline void WordsReplace::add_replace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replace_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:WordsReplace.replace)
}
inline void WordsReplace::add_replace(const char* value, size_t size) {
  _impl_.replace_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:WordsReplace.replace)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WordsReplace::replace() const {
  // @@protoc_insertion_point(field_list:WordsReplace.replace)
  return _impl_.replace_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WordsReplace::mutable_replace() {
  // @@protoc_insertion_point(field_mutable_list:WordsReplace.replace)
  return &_impl_.replace_;
}

// -------------------------------------------------------------------

// StreamingSpeechConfig

// .AudioConfig audioConfig = 1;
inline bool StreamingSpeechConfig::_internal_has_audioconfig() const {
  return this != internal_default_instance() && _impl_.audioconfig_ != nullptr;
}
inline bool StreamingSpeechConfig::has_audioconfig() const {
  return _internal_has_audioconfig();
}
inline void StreamingSpeechConfig::clear_audioconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.audioconfig_ != nullptr) {
    delete _impl_.audioconfig_;
  }
  _impl_.audioconfig_ = nullptr;
}
inline const ::AudioConfig& StreamingSpeechConfig::_internal_audioconfig() const {
  const ::AudioConfig* p = _impl_.audioconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::AudioConfig&>(
      ::_AudioConfig_default_instance_);
}
inline const ::AudioConfig& StreamingSpeechConfig::audioconfig() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechConfig.audioConfig)
  return _internal_audioconfig();
}
inline void StreamingSpeechConfig::unsafe_arena_set_allocated_audioconfig(
    ::AudioConfig* audioconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audioconfig_);
  }
  _impl_.audioconfig_ = audioconfig;
  if (audioconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechConfig.audioConfig)
}
inline ::AudioConfig* StreamingSpeechConfig::release_audioconfig() {
  
  ::AudioConfig* temp = _impl_.audioconfig_;
  _impl_.audioconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AudioConfig* StreamingSpeechConfig::unsafe_arena_release_audioconfig() {
  // @@protoc_insertion_point(field_release:StreamingSpeechConfig.audioConfig)
  
  ::AudioConfig* temp = _impl_.audioconfig_;
  _impl_.audioconfig_ = nullptr;
  return temp;
}
inline ::AudioConfig* StreamingSpeechConfig::_internal_mutable_audioconfig() {
  
  if (_impl_.audioconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::AudioConfig>(GetArenaForAllocation());
    _impl_.audioconfig_ = p;
  }
  return _impl_.audioconfig_;
}
inline ::AudioConfig* StreamingSpeechConfig::mutable_audioconfig() {
  ::AudioConfig* _msg = _internal_mutable_audioconfig();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechConfig.audioConfig)
  return _msg;
}
inline void StreamingSpeechConfig::set_allocated_audioconfig(::AudioConfig* audioconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audioconfig_;
  }
  if (audioconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audioconfig);
    if (message_arena != submessage_arena) {
      audioconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audioconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audioconfig_ = audioconfig;
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechConfig.audioConfig)
}

// .SpeechConfig speechConfig = 2;
inline bool StreamingSpeechConfig::_internal_has_speechconfig() const {
  return this != internal_default_instance() && _impl_.speechconfig_ != nullptr;
}
inline bool StreamingSpeechConfig::has_speechconfig() const {
  return _internal_has_speechconfig();
}
inline void StreamingSpeechConfig::clear_speechconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.speechconfig_ != nullptr) {
    delete _impl_.speechconfig_;
  }
  _impl_.speechconfig_ = nullptr;
}
inline const ::SpeechConfig& StreamingSpeechConfig::_internal_speechconfig() const {
  const ::SpeechConfig* p = _impl_.speechconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::SpeechConfig&>(
      ::_SpeechConfig_default_instance_);
}
inline const ::SpeechConfig& StreamingSpeechConfig::speechconfig() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechConfig.speechConfig)
  return _internal_speechconfig();
}
inline void StreamingSpeechConfig::unsafe_arena_set_allocated_speechconfig(
    ::SpeechConfig* speechconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.speechconfig_);
  }
  _impl_.speechconfig_ = speechconfig;
  if (speechconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechConfig.speechConfig)
}
inline ::SpeechConfig* StreamingSpeechConfig::release_speechconfig() {
  
  ::SpeechConfig* temp = _impl_.speechconfig_;
  _impl_.speechconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SpeechConfig* StreamingSpeechConfig::unsafe_arena_release_speechconfig() {
  // @@protoc_insertion_point(field_release:StreamingSpeechConfig.speechConfig)
  
  ::SpeechConfig* temp = _impl_.speechconfig_;
  _impl_.speechconfig_ = nullptr;
  return temp;
}
inline ::SpeechConfig* StreamingSpeechConfig::_internal_mutable_speechconfig() {
  
  if (_impl_.speechconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpeechConfig>(GetArenaForAllocation());
    _impl_.speechconfig_ = p;
  }
  return _impl_.speechconfig_;
}
inline ::SpeechConfig* StreamingSpeechConfig::mutable_speechconfig() {
  ::SpeechConfig* _msg = _internal_mutable_speechconfig();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechConfig.speechConfig)
  return _msg;
}
inline void StreamingSpeechConfig::set_allocated_speechconfig(::SpeechConfig* speechconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.speechconfig_;
  }
  if (speechconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(speechconfig);
    if (message_arena != submessage_arena) {
      speechconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speechconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.speechconfig_ = speechconfig;
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechConfig.speechConfig)
}

// -------------------------------------------------------------------

// StreamingSpeechRequest

// .StreamingSpeechConfig streamingSpeechConfig = 1;
inline bool StreamingSpeechRequest::_internal_has_streamingspeechconfig() const {
  return requestPayload_case() == kStreamingSpeechConfig;
}
inline bool StreamingSpeechRequest::has_streamingspeechconfig() const {
  return _internal_has_streamingspeechconfig();
}
inline void StreamingSpeechRequest::set_has_streamingspeechconfig() {
  _impl_._oneof_case_[0] = kStreamingSpeechConfig;
}
inline void StreamingSpeechRequest::clear_streamingspeechconfig() {
  if (_internal_has_streamingspeechconfig()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requestPayload_.streamingspeechconfig_;
    }
    clear_has_requestPayload();
  }
}
inline ::StreamingSpeechConfig* StreamingSpeechRequest::release_streamingspeechconfig() {
  // @@protoc_insertion_point(field_release:StreamingSpeechRequest.streamingSpeechConfig)
  if (_internal_has_streamingspeechconfig()) {
    clear_has_requestPayload();
    ::StreamingSpeechConfig* temp = _impl_.requestPayload_.streamingspeechconfig_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requestPayload_.streamingspeechconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StreamingSpeechConfig& StreamingSpeechRequest::_internal_streamingspeechconfig() const {
  return _internal_has_streamingspeechconfig()
      ? *_impl_.requestPayload_.streamingspeechconfig_
      : reinterpret_cast< ::StreamingSpeechConfig&>(::_StreamingSpeechConfig_default_instance_);
}
inline const ::StreamingSpeechConfig& StreamingSpeechRequest::streamingspeechconfig() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechRequest.streamingSpeechConfig)
  return _internal_streamingspeechconfig();
}
inline ::StreamingSpeechConfig* StreamingSpeechRequest::unsafe_arena_release_streamingspeechconfig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StreamingSpeechRequest.streamingSpeechConfig)
  if (_internal_has_streamingspeechconfig()) {
    clear_has_requestPayload();
    ::StreamingSpeechConfig* temp = _impl_.requestPayload_.streamingspeechconfig_;
    _impl_.requestPayload_.streamingspeechconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamingSpeechRequest::unsafe_arena_set_allocated_streamingspeechconfig(::StreamingSpeechConfig* streamingspeechconfig) {
  clear_requestPayload();
  if (streamingspeechconfig) {
    set_has_streamingspeechconfig();
    _impl_.requestPayload_.streamingspeechconfig_ = streamingspeechconfig;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechRequest.streamingSpeechConfig)
}
inline ::StreamingSpeechConfig* StreamingSpeechRequest::_internal_mutable_streamingspeechconfig() {
  if (!_internal_has_streamingspeechconfig()) {
    clear_requestPayload();
    set_has_streamingspeechconfig();
    _impl_.requestPayload_.streamingspeechconfig_ = CreateMaybeMessage< ::StreamingSpeechConfig >(GetArenaForAllocation());
  }
  return _impl_.requestPayload_.streamingspeechconfig_;
}
inline ::StreamingSpeechConfig* StreamingSpeechRequest::mutable_streamingspeechconfig() {
  ::StreamingSpeechConfig* _msg = _internal_mutable_streamingspeechconfig();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechRequest.streamingSpeechConfig)
  return _msg;
}

// bytes audioData = 2;
inline bool StreamingSpeechRequest::_internal_has_audiodata() const {
  return requestPayload_case() == kAudioData;
}
inline bool StreamingSpeechRequest::has_audiodata() const {
  return _internal_has_audiodata();
}
inline void StreamingSpeechRequest::set_has_audiodata() {
  _impl_._oneof_case_[0] = kAudioData;
}
inline void StreamingSpeechRequest::clear_audiodata() {
  if (_internal_has_audiodata()) {
    _impl_.requestPayload_.audiodata_.Destroy();
    clear_has_requestPayload();
  }
}
inline const std::string& StreamingSpeechRequest::audiodata() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechRequest.audioData)
  return _internal_audiodata();
}
template <typename ArgT0, typename... ArgT>
inline void StreamingSpeechRequest::set_audiodata(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiodata()) {
    clear_requestPayload();
    set_has_audiodata();
    _impl_.requestPayload_.audiodata_.InitDefault();
  }
  _impl_.requestPayload_.audiodata_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamingSpeechRequest.audioData)
}
inline std::string* StreamingSpeechRequest::mutable_audiodata() {
  std::string* _s = _internal_mutable_audiodata();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechRequest.audioData)
  return _s;
}
inline const std::string& StreamingSpeechRequest::_internal_audiodata() const {
  if (_internal_has_audiodata()) {
    return _impl_.requestPayload_.audiodata_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StreamingSpeechRequest::_internal_set_audiodata(const std::string& value) {
  if (!_internal_has_audiodata()) {
    clear_requestPayload();
    set_has_audiodata();
    _impl_.requestPayload_.audiodata_.InitDefault();
  }
  _impl_.requestPayload_.audiodata_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamingSpeechRequest::_internal_mutable_audiodata() {
  if (!_internal_has_audiodata()) {
    clear_requestPayload();
    set_has_audiodata();
    _impl_.requestPayload_.audiodata_.InitDefault();
  }
  return _impl_.requestPayload_.audiodata_.Mutable(      GetArenaForAllocation());
}
inline std::string* StreamingSpeechRequest::release_audiodata() {
  // @@protoc_insertion_point(field_release:StreamingSpeechRequest.audioData)
  if (_internal_has_audiodata()) {
    clear_has_requestPayload();
    return _impl_.requestPayload_.audiodata_.Release();
  } else {
    return nullptr;
  }
}
inline void StreamingSpeechRequest::set_allocated_audiodata(std::string* audiodata) {
  if (has_requestPayload()) {
    clear_requestPayload();
  }
  if (audiodata != nullptr) {
    set_has_audiodata();
    _impl_.requestPayload_.audiodata_.InitAllocated(audiodata, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechRequest.audioData)
}

inline bool StreamingSpeechRequest::has_requestPayload() const {
  return requestPayload_case() != REQUESTPAYLOAD_NOT_SET;
}
inline void StreamingSpeechRequest::clear_has_requestPayload() {
  _impl_._oneof_case_[0] = REQUESTPAYLOAD_NOT_SET;
}
inline StreamingSpeechRequest::RequestPayloadCase StreamingSpeechRequest::requestPayload_case() const {
  return StreamingSpeechRequest::RequestPayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamingSpeechResponse

// string globalStreamId = 1;
inline void StreamingSpeechResponse::clear_globalstreamid() {
  _impl_.globalstreamid_.ClearToEmpty();
}
inline const std::string& StreamingSpeechResponse::globalstreamid() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechResponse.globalStreamId)
  return _internal_globalstreamid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamingSpeechResponse::set_globalstreamid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.globalstreamid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamingSpeechResponse.globalStreamId)
}
inline std::string* StreamingSpeechResponse::mutable_globalstreamid() {
  std::string* _s = _internal_mutable_globalstreamid();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechResponse.globalStreamId)
  return _s;
}
inline const std::string& StreamingSpeechResponse::_internal_globalstreamid() const {
  return _impl_.globalstreamid_.Get();
}
inline void StreamingSpeechResponse::_internal_set_globalstreamid(const std::string& value) {
  
  _impl_.globalstreamid_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamingSpeechResponse::_internal_mutable_globalstreamid() {
  
  return _impl_.globalstreamid_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamingSpeechResponse::release_globalstreamid() {
  // @@protoc_insertion_point(field_release:StreamingSpeechResponse.globalStreamId)
  return _impl_.globalstreamid_.Release();
}
inline void StreamingSpeechResponse::set_allocated_globalstreamid(std::string* globalstreamid) {
  if (globalstreamid != nullptr) {
    
  } else {
    
  }
  _impl_.globalstreamid_.SetAllocated(globalstreamid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.globalstreamid_.IsDefault()) {
    _impl_.globalstreamid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechResponse.globalStreamId)
}

// .StreamingSpeechResult result = 2;
inline bool StreamingSpeechResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool StreamingSpeechResponse::has_result() const {
  return _internal_has_result();
}
inline void StreamingSpeechResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::StreamingSpeechResult& StreamingSpeechResponse::_internal_result() const {
  const ::StreamingSpeechResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::StreamingSpeechResult&>(
      ::_StreamingSpeechResult_default_instance_);
}
inline const ::StreamingSpeechResult& StreamingSpeechResponse::result() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechResponse.result)
  return _internal_result();
}
inline void StreamingSpeechResponse::unsafe_arena_set_allocated_result(
    ::StreamingSpeechResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechResponse.result)
}
inline ::StreamingSpeechResult* StreamingSpeechResponse::release_result() {
  
  ::StreamingSpeechResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StreamingSpeechResult* StreamingSpeechResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:StreamingSpeechResponse.result)
  
  ::StreamingSpeechResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::StreamingSpeechResult* StreamingSpeechResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::StreamingSpeechResult>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::StreamingSpeechResult* StreamingSpeechResponse::mutable_result() {
  ::StreamingSpeechResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechResponse.result)
  return _msg;
}
inline void StreamingSpeechResponse::set_allocated_result(::StreamingSpeechResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechResponse.result)
}

// .StreamingSpeechStatus status = 3;
inline bool StreamingSpeechResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool StreamingSpeechResponse::has_status() const {
  return _internal_has_status();
}
inline void StreamingSpeechResponse::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::StreamingSpeechStatus& StreamingSpeechResponse::_internal_status() const {
  const ::StreamingSpeechStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::StreamingSpeechStatus&>(
      ::_StreamingSpeechStatus_default_instance_);
}
inline const ::StreamingSpeechStatus& StreamingSpeechResponse::status() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechResponse.status)
  return _internal_status();
}
inline void StreamingSpeechResponse::unsafe_arena_set_allocated_status(
    ::StreamingSpeechStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechResponse.status)
}
inline ::StreamingSpeechStatus* StreamingSpeechResponse::release_status() {
  
  ::StreamingSpeechStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StreamingSpeechStatus* StreamingSpeechResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:StreamingSpeechResponse.status)
  
  ::StreamingSpeechStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::StreamingSpeechStatus* StreamingSpeechResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::StreamingSpeechStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::StreamingSpeechStatus* StreamingSpeechResponse::mutable_status() {
  ::StreamingSpeechStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechResponse.status)
  return _msg;
}
inline void StreamingSpeechResponse::set_allocated_status(::StreamingSpeechStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechResponse.status)
}

// -------------------------------------------------------------------

// StreamingSpeechResult

// bool isFinal = 1;
inline void StreamingSpeechResult::clear_isfinal() {
  _impl_.isfinal_ = false;
}
inline bool StreamingSpeechResult::_internal_isfinal() const {
  return _impl_.isfinal_;
}
inline bool StreamingSpeechResult::isfinal() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechResult.isFinal)
  return _internal_isfinal();
}
inline void StreamingSpeechResult::_internal_set_isfinal(bool value) {
  
  _impl_.isfinal_ = value;
}
inline void StreamingSpeechResult::set_isfinal(bool value) {
  _internal_set_isfinal(value);
  // @@protoc_insertion_point(field_set:StreamingSpeechResult.isFinal)
}

// .StreamingTranscription bestTranscription = 2;
inline bool StreamingSpeechResult::_internal_has_besttranscription() const {
  return this != internal_default_instance() && _impl_.besttranscription_ != nullptr;
}
inline bool StreamingSpeechResult::has_besttranscription() const {
  return _internal_has_besttranscription();
}
inline void StreamingSpeechResult::clear_besttranscription() {
  if (GetArenaForAllocation() == nullptr && _impl_.besttranscription_ != nullptr) {
    delete _impl_.besttranscription_;
  }
  _impl_.besttranscription_ = nullptr;
}
inline const ::StreamingTranscription& StreamingSpeechResult::_internal_besttranscription() const {
  const ::StreamingTranscription* p = _impl_.besttranscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::StreamingTranscription&>(
      ::_StreamingTranscription_default_instance_);
}
inline const ::StreamingTranscription& StreamingSpeechResult::besttranscription() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechResult.bestTranscription)
  return _internal_besttranscription();
}
inline void StreamingSpeechResult::unsafe_arena_set_allocated_besttranscription(
    ::StreamingTranscription* besttranscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.besttranscription_);
  }
  _impl_.besttranscription_ = besttranscription;
  if (besttranscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamingSpeechResult.bestTranscription)
}
inline ::StreamingTranscription* StreamingSpeechResult::release_besttranscription() {
  
  ::StreamingTranscription* temp = _impl_.besttranscription_;
  _impl_.besttranscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StreamingTranscription* StreamingSpeechResult::unsafe_arena_release_besttranscription() {
  // @@protoc_insertion_point(field_release:StreamingSpeechResult.bestTranscription)
  
  ::StreamingTranscription* temp = _impl_.besttranscription_;
  _impl_.besttranscription_ = nullptr;
  return temp;
}
inline ::StreamingTranscription* StreamingSpeechResult::_internal_mutable_besttranscription() {
  
  if (_impl_.besttranscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::StreamingTranscription>(GetArenaForAllocation());
    _impl_.besttranscription_ = p;
  }
  return _impl_.besttranscription_;
}
inline ::StreamingTranscription* StreamingSpeechResult::mutable_besttranscription() {
  ::StreamingTranscription* _msg = _internal_mutable_besttranscription();
  // @@protoc_insertion_point(field_mutable:StreamingSpeechResult.bestTranscription)
  return _msg;
}
inline void StreamingSpeechResult::set_allocated_besttranscription(::StreamingTranscription* besttranscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.besttranscription_;
  }
  if (besttranscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(besttranscription);
    if (message_arena != submessage_arena) {
      besttranscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, besttranscription, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.besttranscription_ = besttranscription;
  // @@protoc_insertion_point(field_set_allocated:StreamingSpeechResult.bestTranscription)
}

// -------------------------------------------------------------------

// StreamingSpeechStatus

// int64 processedTimestamp = 1;
inline void StreamingSpeechStatus::clear_processedtimestamp() {
  _impl_.processedtimestamp_ = int64_t{0};
}
inline int64_t StreamingSpeechStatus::_internal_processedtimestamp() const {
  return _impl_.processedtimestamp_;
}
inline int64_t StreamingSpeechStatus::processedtimestamp() const {
  // @@protoc_insertion_point(field_get:StreamingSpeechStatus.processedTimestamp)
  return _internal_processedtimestamp();
}
inline void StreamingSpeechStatus::_internal_set_processedtimestamp(int64_t value) {
  
  _impl_.processedtimestamp_ = value;
}
inline void StreamingSpeechStatus::set_processedtimestamp(int64_t value) {
  _internal_set_processedtimestamp(value);
  // @@protoc_insertion_point(field_set:StreamingSpeechStatus.processedTimestamp)
}

// -------------------------------------------------------------------

// StreamingTranscription

// string transcribedText = 1;
inline void StreamingTranscription::clear_transcribedtext() {
  _impl_.transcribedtext_.ClearToEmpty();
}
inline const std::string& StreamingTranscription::transcribedtext() const {
  // @@protoc_insertion_point(field_get:StreamingTranscription.transcribedText)
  return _internal_transcribedtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamingTranscription::set_transcribedtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transcribedtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamingTranscription.transcribedText)
}
inline std::string* StreamingTranscription::mutable_transcribedtext() {
  std::string* _s = _internal_mutable_transcribedtext();
  // @@protoc_insertion_point(field_mutable:StreamingTranscription.transcribedText)
  return _s;
}
inline const std::string& StreamingTranscription::_internal_transcribedtext() const {
  return _impl_.transcribedtext_.Get();
}
inline void StreamingTranscription::_internal_set_transcribedtext(const std::string& value) {
  
  _impl_.transcribedtext_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamingTranscription::_internal_mutable_transcribedtext() {
  
  return _impl_.transcribedtext_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamingTranscription::release_transcribedtext() {
  // @@protoc_insertion_point(field_release:StreamingTranscription.transcribedText)
  return _impl_.transcribedtext_.Release();
}
inline void StreamingTranscription::set_allocated_transcribedtext(std::string* transcribedtext) {
  if (transcribedtext != nullptr) {
    
  } else {
    
  }
  _impl_.transcribedtext_.SetAllocated(transcribedtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transcribedtext_.IsDefault()) {
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamingTranscription.transcribedText)
}

// repeated .KeyWordsType keyWordsType = 2;
inline int StreamingTranscription::_internal_keywordstype_size() const {
  return _impl_.keywordstype_.size();
}
inline int StreamingTranscription::keywordstype_size() const {
  return _internal_keywordstype_size();
}
inline void StreamingTranscription::clear_keywordstype() {
  _impl_.keywordstype_.Clear();
}
inline ::KeyWordsType* StreamingTranscription::mutable_keywordstype(int index) {
  // @@protoc_insertion_point(field_mutable:StreamingTranscription.keyWordsType)
  return _impl_.keywordstype_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KeyWordsType >*
StreamingTranscription::mutable_keywordstype() {
  // @@protoc_insertion_point(field_mutable_list:StreamingTranscription.keyWordsType)
  return &_impl_.keywordstype_;
}
inline const ::KeyWordsType& StreamingTranscription::_internal_keywordstype(int index) const {
  return _impl_.keywordstype_.Get(index);
}
inline const ::KeyWordsType& StreamingTranscription::keywordstype(int index) const {
  // @@protoc_insertion_point(field_get:StreamingTranscription.keyWordsType)
  return _internal_keywordstype(index);
}
inline ::KeyWordsType* StreamingTranscription::_internal_add_keywordstype() {
  return _impl_.keywordstype_.Add();
}
inline ::KeyWordsType* StreamingTranscription::add_keywordstype() {
  ::KeyWordsType* _add = _internal_add_keywordstype();
  // @@protoc_insertion_point(field_add:StreamingTranscription.keyWordsType)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::KeyWordsType >&
StreamingTranscription::keywordstype() const {
  // @@protoc_insertion_point(field_list:StreamingTranscription.keyWordsType)
  return _impl_.keywordstype_;
}

// repeated .StreamingTranscriptionPiece piece = 3;
inline int StreamingTranscription::_internal_piece_size() const {
  return _impl_.piece_.size();
}
inline int StreamingTranscription::piece_size() const {
  return _internal_piece_size();
}
inline void StreamingTranscription::clear_piece() {
  _impl_.piece_.Clear();
}
inline ::StreamingTranscriptionPiece* StreamingTranscription::mutable_piece(int index) {
  // @@protoc_insertion_point(field_mutable:StreamingTranscription.piece)
  return _impl_.piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StreamingTranscriptionPiece >*
StreamingTranscription::mutable_piece() {
  // @@protoc_insertion_point(field_mutable_list:StreamingTranscription.piece)
  return &_impl_.piece_;
}
inline const ::StreamingTranscriptionPiece& StreamingTranscription::_internal_piece(int index) const {
  return _impl_.piece_.Get(index);
}
inline const ::StreamingTranscriptionPiece& StreamingTranscription::piece(int index) const {
  // @@protoc_insertion_point(field_get:StreamingTranscription.piece)
  return _internal_piece(index);
}
inline ::StreamingTranscriptionPiece* StreamingTranscription::_internal_add_piece() {
  return _impl_.piece_.Add();
}
inline ::StreamingTranscriptionPiece* StreamingTranscription::add_piece() {
  ::StreamingTranscriptionPiece* _add = _internal_add_piece();
  // @@protoc_insertion_point(field_add:StreamingTranscription.piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StreamingTranscriptionPiece >&
StreamingTranscription::piece() const {
  // @@protoc_insertion_point(field_list:StreamingTranscription.piece)
  return _impl_.piece_;
}

// -------------------------------------------------------------------

// KeyWordsType

// string keyWords = 1;
inline void KeyWordsType::clear_keywords() {
  _impl_.keywords_.ClearToEmpty();
}
inline const std::string& KeyWordsType::keywords() const {
  // @@protoc_insertion_point(field_get:KeyWordsType.keyWords)
  return _internal_keywords();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyWordsType::set_keywords(ArgT0&& arg0, ArgT... args) {
 
 _impl_.keywords_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KeyWordsType.keyWords)
}
inline std::string* KeyWordsType::mutable_keywords() {
  std::string* _s = _internal_mutable_keywords();
  // @@protoc_insertion_point(field_mutable:KeyWordsType.keyWords)
  return _s;
}
inline const std::string& KeyWordsType::_internal_keywords() const {
  return _impl_.keywords_.Get();
}
inline void KeyWordsType::_internal_set_keywords(const std::string& value) {
  
  _impl_.keywords_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyWordsType::_internal_mutable_keywords() {
  
  return _impl_.keywords_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyWordsType::release_keywords() {
  // @@protoc_insertion_point(field_release:KeyWordsType.keyWords)
  return _impl_.keywords_.Release();
}
inline void KeyWordsType::set_allocated_keywords(std::string* keywords) {
  if (keywords != nullptr) {
    
  } else {
    
  }
  _impl_.keywords_.SetAllocated(keywords, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keywords_.IsDefault()) {
    _impl_.keywords_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KeyWordsType.keyWords)
}

// float keyWordsScore = 2;
inline void KeyWordsType::clear_keywordsscore() {
  _impl_.keywordsscore_ = 0;
}
inline float KeyWordsType::_internal_keywordsscore() const {
  return _impl_.keywordsscore_;
}
inline float KeyWordsType::keywordsscore() const {
  // @@protoc_insertion_point(field_get:KeyWordsType.keyWordsScore)
  return _internal_keywordsscore();
}
inline void KeyWordsType::_internal_set_keywordsscore(float value) {
  
  _impl_.keywordsscore_ = value;
}
inline void KeyWordsType::set_keywordsscore(float value) {
  _internal_set_keywordsscore(value);
  // @@protoc_insertion_point(field_set:KeyWordsType.keyWordsScore)
}

// int32 startTimestamp = 3;
inline void KeyWordsType::clear_starttimestamp() {
  _impl_.starttimestamp_ = 0;
}
inline int32_t KeyWordsType::_internal_starttimestamp() const {
  return _impl_.starttimestamp_;
}
inline int32_t KeyWordsType::starttimestamp() const {
  // @@protoc_insertion_point(field_get:KeyWordsType.startTimestamp)
  return _internal_starttimestamp();
}
inline void KeyWordsType::_internal_set_starttimestamp(int32_t value) {
  
  _impl_.starttimestamp_ = value;
}
inline void KeyWordsType::set_starttimestamp(int32_t value) {
  _internal_set_starttimestamp(value);
  // @@protoc_insertion_point(field_set:KeyWordsType.startTimestamp)
}

// int32 endTimestamp = 4;
inline void KeyWordsType::clear_endtimestamp() {
  _impl_.endtimestamp_ = 0;
}
inline int32_t KeyWordsType::_internal_endtimestamp() const {
  return _impl_.endtimestamp_;
}
inline int32_t KeyWordsType::endtimestamp() const {
  // @@protoc_insertion_point(field_get:KeyWordsType.endTimestamp)
  return _internal_endtimestamp();
}
inline void KeyWordsType::_internal_set_endtimestamp(int32_t value) {
  
  _impl_.endtimestamp_ = value;
}
inline void KeyWordsType::set_endtimestamp(int32_t value) {
  _internal_set_endtimestamp(value);
  // @@protoc_insertion_point(field_set:KeyWordsType.endTimestamp)
}

// -------------------------------------------------------------------

// StreamingTranscriptionPiece

// string transcribedText = 1;
inline void StreamingTranscriptionPiece::clear_transcribedtext() {
  _impl_.transcribedtext_.ClearToEmpty();
}
inline const std::string& StreamingTranscriptionPiece::transcribedtext() const {
  // @@protoc_insertion_point(field_get:StreamingTranscriptionPiece.transcribedText)
  return _internal_transcribedtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamingTranscriptionPiece::set_transcribedtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transcribedtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamingTranscriptionPiece.transcribedText)
}
inline std::string* StreamingTranscriptionPiece::mutable_transcribedtext() {
  std::string* _s = _internal_mutable_transcribedtext();
  // @@protoc_insertion_point(field_mutable:StreamingTranscriptionPiece.transcribedText)
  return _s;
}
inline const std::string& StreamingTranscriptionPiece::_internal_transcribedtext() const {
  return _impl_.transcribedtext_.Get();
}
inline void StreamingTranscriptionPiece::_internal_set_transcribedtext(const std::string& value) {
  
  _impl_.transcribedtext_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamingTranscriptionPiece::_internal_mutable_transcribedtext() {
  
  return _impl_.transcribedtext_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamingTranscriptionPiece::release_transcribedtext() {
  // @@protoc_insertion_point(field_release:StreamingTranscriptionPiece.transcribedText)
  return _impl_.transcribedtext_.Release();
}
inline void StreamingTranscriptionPiece::set_allocated_transcribedtext(std::string* transcribedtext) {
  if (transcribedtext != nullptr) {
    
  } else {
    
  }
  _impl_.transcribedtext_.SetAllocated(transcribedtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transcribedtext_.IsDefault()) {
    _impl_.transcribedtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamingTranscriptionPiece.transcribedText)
}

// int64 beginTimestamp = 2;
inline void StreamingTranscriptionPiece::clear_begintimestamp() {
  _impl_.begintimestamp_ = int64_t{0};
}
inline int64_t StreamingTranscriptionPiece::_internal_begintimestamp() const {
  return _impl_.begintimestamp_;
}
inline int64_t StreamingTranscriptionPiece::begintimestamp() const {
  // @@protoc_insertion_point(field_get:StreamingTranscriptionPiece.beginTimestamp)
  return _internal_begintimestamp();
}
inline void StreamingTranscriptionPiece::_internal_set_begintimestamp(int64_t value) {
  
  _impl_.begintimestamp_ = value;
}
inline void StreamingTranscriptionPiece::set_begintimestamp(int64_t value) {
  _internal_set_begintimestamp(value);
  // @@protoc_insertion_point(field_set:StreamingTranscriptionPiece.beginTimestamp)
}

// int64 endTimestamp = 3;
inline void StreamingTranscriptionPiece::clear_endtimestamp() {
  _impl_.endtimestamp_ = int64_t{0};
}
inline int64_t StreamingTranscriptionPiece::_internal_endtimestamp() const {
  return _impl_.endtimestamp_;
}
inline int64_t StreamingTranscriptionPiece::endtimestamp() const {
  // @@protoc_insertion_point(field_get:StreamingTranscriptionPiece.endTimestamp)
  return _internal_endtimestamp();
}
inline void StreamingTranscriptionPiece::_internal_set_endtimestamp(int64_t value) {
  
  _impl_.endtimestamp_ = value;
}
inline void StreamingTranscriptionPiece::set_endtimestamp(int64_t value) {
  _internal_set_endtimestamp(value);
  // @@protoc_insertion_point(field_set:StreamingTranscriptionPiece.endTimestamp)
}

// int32 transcribedType = 4;
inline void StreamingTranscriptionPiece::clear_transcribedtype() {
  _impl_.transcribedtype_ = 0;
}
inline int32_t StreamingTranscriptionPiece::_internal_transcribedtype() const {
  return _impl_.transcribedtype_;
}
inline int32_t StreamingTranscriptionPiece::transcribedtype() const {
  // @@protoc_insertion_point(field_get:StreamingTranscriptionPiece.transcribedType)
  return _internal_transcribedtype();
}
inline void StreamingTranscriptionPiece::_internal_set_transcribedtype(int32_t value) {
  
  _impl_.transcribedtype_ = value;
}
inline void StreamingTranscriptionPiece::set_transcribedtype(int32_t value) {
  _internal_set_transcribedtype(value);
  // @@protoc_insertion_point(field_set:StreamingTranscriptionPiece.transcribedType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AudioConfig_AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AudioConfig_AudioEncoding>() {
  return ::AudioConfig_AudioEncoding_descriptor();
}
template <> struct is_proto_enum< ::SpeechConfig_Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpeechConfig_Language>() {
  return ::SpeechConfig_Language_descriptor();
}
template <> struct is_proto_enum< ::SpeechConfig_Scene> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpeechConfig_Scene>() {
  return ::SpeechConfig_Scene_descriptor();
}
template <> struct is_proto_enum< ::SpeechConfig_RecognizeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpeechConfig_RecognizeType>() {
  return ::SpeechConfig_RecognizeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_yitu_5fstreaming_2eproto
